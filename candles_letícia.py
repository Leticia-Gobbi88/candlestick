# -*- coding: utf-8 -*-
"""Candles_let√≠cia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ucuv-o1YrfOBzfUzfaj7Miu74cvPTopo

# Desafio Candles![b12e17_1a71b33107174d25a437d93f0d97120d~mv2.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAACTwAAAMuCAYAAAA+R176AAAACXBIWXMAAC4jAAAuIwF4pT92AAAgAElEQVR4nOzdW3Ic15Uu4KRD7w2PoKkRGBqBoRG4lG33a5PvHUHAVj6TfOuIOnEAjQB09NuJUDHPCESNQOgRmD2Cgx6BTiS1IRVAXOqWmXuv/X0RDMsUL1lZFMn8619rP2sAAAAAAAAAYCLf/K/vT5qmObn7sz1rft7zAn77/j8/+/yj8Pt+/Hs/ML/1lbe+z4fv//qvH/a7RoB8/Pt//seb337fu+/34F++7tnDvy/u8G1/+7qbb/ts7et/vufb/u7Zz3e/97sv/DoCAAAAAAAAYEJD2el1oTdc4QmIpNjfi3+XwUUAAAAAAAAAAABsROEJAAAAAAAAAAAohsITAAAAAAAAAABQDIUnAAAAAAAAAACgGApPAAAAAAAAAABAMRSeAAAAAAAAAACAYig8AQAAAAAAAAAAxVB4AgAAAAAAAAAAiqHwBAAAAAAAAAAAFEPhCQAAAAAAAAAAKIbCEwAAAAAAAAAAUAyFJwAAAAAAAAAAoBgKTwAAAAAAAAAAQDEUngAAAAAAAAAAgGIoPAEAAAAAAAAAAMVQeAIAAAAAAAAAAIqh8AQAAAAAAAAAABRD4QkAAAAAAAAAACiGwhMAAAAAAAAAAFAMhScAAAAAAAAAAKAYCk8AAAAAAAAAAEAxFJ4AAAAAAAAAAIBiKDwBAAAAAAAAAADFUHgCAAAAAAAAAACKofAEAAAAAAAAAAAUQ+EJAAAAAAAAAAAohsITAAAAAAAAAABQDIUnAAAAAAAAAACgGApPAAAAAAAAAABAMRSeAAAAAAAAAACAYig8AQAAAAAAAAAAxVB4AgAAAAAAAAAAiqHwBAAAAAAAAAAAFEPhCQAAAAAAAAAAKIbCEwAAAAAAAAAAUAyFJwAAAAAAAAAAoBgKTwAAAAAAAAAAQDEUngAAAAAAAAAAgGIoPAEAAAAAAAAAAMVQeAIAAAAAAAAAAIqh8AQAAAAAAAAAABRD4QkAAAAAAAAAACiGwhMAAAAAAAAAAFAMhScAAAAAAAAAAKAYCk8AAAAAAAAAAEAxFJ4AAAAAAAAAAIBiKDwBAAAAAAAAAADFUHgCAAAAAAAAAACKofAEAAAAAAAAAAAUQ+EJAAAAAAAAAAAohsITAAAAAAAAAABQDIUnAAAAAAAAAACgGApPAAAAAAAAAABAMRSeAAAAAAAAAACAYig8AQAAAAAAAAAAxVB4AgAAAAAAAAAAiqHwBAAAAAAAAAAAFEPhCQAAAAAAAAAAKIbCEwAAAAAAAAAAUAyFJwAAAAAAAAAAoBgKTwAAAAAAAAAAQDEUngAAAAAAAAAAgGIoPAEAAAAAAAAAAMVQeAIAAAAAAAAAAIqh8AQAAAAAAAAAABRD4QkAAAAAAAAAACiGwhMAAAAAAAAAAFAMhScAAAAAAAAAAKAYCk8AAAAAAAAAAEAxFJ4AAAAAAAAAAIBiKDwBAAAAAAAAAADFUHgCAAAAAAAAAACKofAEAAAAAAAAAAAUQ+EJAAAAAAAAAAAohsITAAAAAAAAAABQDIUnAAAAAAAAAACgGApPAAAAAAAAAABAMRSeAAAAAAAAAACAYig8AQAAAAAAAAAAxVB4AgAAAAAAAAAAiqHwBAAAAAAAAAAAFEPhCQAAAAAAAAAAKIbCEwAAAAAAAAAAUAyFJwAAAAAAAAAAoBgKTwAAAAAAAAAAQDEUngAAAAAAAAAAgGIoPAEAAAAAAAAAAMVQeAIAAAAAAAAAAIqh8AQAAAAAAAAAABRD4QkAAAAAAAAAACiGwhMAAAAAAAAAAFAMhScAAAAAAAAAAKAYCk8AAAAAAAAAAEAxFJ4AAAAAAAAAAIBiKDwBAAAAAAAAAADFUHgCAAAAAAAAAACKofAEAAAAAAAAAAAUQ+EJAAAAAAAAAAAohsITAAAAAAAAAABQDIUnAAAAAAAAAACgGApPAAAAAAAAAABAMRSeAAAAAAAAAACAYig8AQAAAAAAAAAAxVB4AgAAAAAAAAAAiqHwBAAAAAAAAAAAFEPhCQAAAAAAAAAAKIbCEwAAAAAAAAAAUAyFJwAAAAAAAAAAoBgKTwAAAAAAAAAAQDEUngAAAAAAAAAAgGIoPAEAAAAAAAAAAMVQeAIAAAAAAAAAAIqh8AQAAAAAAAAAABRD4QkAAAAAAAAAACiGwhMAAAAAAAAAAFAMhScAAAAAAAAAAKAYCk8AAAAAAAAAAEAxFJ4AAAAAAAAAAIBifLFYrp43TfPCWwbM7MNjP33ftY/+ewCAmlT0HNf3XXuVwXUQ1GK5Gv47eu79BQD29EF+yVQq+Tvsdd+1FxlcBwCQsS/SX4pee5OAmT36+9BiuXroX90NEq6bpvmvR77NtQ/NAIAAXldSePpj0zRfZ3AdxPVvTdOceH8BgANQeGJ0afjlsoY7vViurhQJAYDHfOHuAIW778OJxZ3/f6tMdac8dZVKUjf//D93v95DFQCQk8q29J4slqsTfx8DAAD4pKYFBq8VCQGAxyg8AbU7Xnv99052rxWkrlMRqlkrR/36dT6IAwAmUtuGXiE3AABQvcqGXxoDMADAUxSeADZ3tFaK+qwctVaMulorQg2lqI83X/qu/eh+AwC7qjDgboTcAAAAn9Q2/NIYgAEAHqPwBHB4N1ujHipF3S1EDQ9s133XXnkvAIAn1BhwN0JuAACgZpUOvzQGYACAxyg8AUzvbiHq0weXqQx1sw1qvQxlMxQAUHPA3Qi5AQCAytU6/NIYgAEAHqLwBJCX5+nLfWWoq1SG+q+bf7YVCgCqUnPAPbhsmubLDK4DAABgMovl6rji4ZfGAAwA8BCFJ4ByHKcvi5srvqcIZSMUAARU+XanG88Xy9WLvmvf5XE5AAAAkzh3mz/dg68yuA4AICMKTwDlWy9C3WyEuk5FqKubjVC2QQFA0S69fZ8Mf9dReAIAAKowbDZaOw2gZscGYACAuxSeAGI6Sg/Cvz4Mp21QH5SgAKAsAu5bbHkCAABqUvvR5usMwAAAtyg8AdTlqRLUB8fhAUB2BNy3CbkBAIDwDL98xgAMAHCLwhMAd0tQN8fh/XhThuq79rr6uwQAMxBw30vIDQAA1MDwy+cMwAAAv1J4AuCu9ePwPj1UL5arq1R+sgUKAKYl4L6fkBsAAAjL8MuDDMAAAL9SeAJgE8fpyyeL5epjKkD9qAAFAOMQcD9KyA0AAERm+OVhBmAAgE8UngDYxfOmaV6kLwpQADAOAffjhNwAAEA4hl+eZAAGAPjkd24DAAdwU4C6bJrmH4vl6qfFcnW+WK4Wbi4AbE/AvZFPIXcB1wkAALANwy9Pc48AABueABjFzRF4p4vlavjx+7T9qbf9CQA2IrzdjC1PAABAGIZfNmbLEwBgwxMAkxg2PZ3f2f507NYDwOcE3Fux5QkAAIjE8Mvm3CsAqJzCEwBT+7T5qWmaofj0/xbL1aWj7wDgFqHtdoYi9VFJFwwAAHCX4ZetGYABgMopPAEwp+HDyeGh9L3yEwAIuHd0lMrUAAAAJbv07m3ttQEYAKiXwhMAuVB+AgDbnXb1SsgNAACUKm0qeu4N3NpzAzAAUC+FJwBypPwEQHVSwG27025seQIAAEpm+GV3BmAAoFIKTwDkbr389I/FcnW+WK6OvWsABCTg3o+QGwAAKI7tTnszAAMAlVJ4AqAkNyuKf1osV8OXUx9sAhCBgPsghNwAAECJDL/szwAMAFRI4QmAUg1bns6bprk58s4RQACUTMB9GEJuAACgGIZfDsYADABUSOEJgAiGYOCHdOTdGx90AlASAfdBCbkBAICSGH45HAMwAFAZhScAInmeQgJbnwAoiYD7sITcAABA9gy/HJwBGACojMITAFGtb3164YNPAHIk4B6FkBsAACiB4ZfDMwADABVReAIguuFD5MumaW6Ou/OhMgA5EXCPQ8gNAABky/DLaAzAAEBFFJ4AqMVR+lD5H+m4u2PvPABzEnCPSsgNAADkzPDLeAzAAEAlFJ4AqNHwAfNPi+VqOPLuxK8AAGYi4B7XK5sdAQCA3Bh+GZ0BGACohMITADUbyk5D6ekfKWgAgEkIuCdxpFQGAADkJG0e8pwyPlueAKACCk8A8MsHzpeKTwBMSMA9jRe2PAEAABk5NfwyCcUyAKjAF95kAPjVTfFpeBh+23ftO7cGgENbLFdvBNyTGv5cf1nR6wUAADKUNg698t5M5nSxXH3Xd+3HSl4v0/nnf/nf/+dkm5/t2a3/9/NT3+Dhb/fUd9noG3/+497862dPfLutfpr177/xxf72fZ49eU+ePfD1933/7V7Ls09ffv71/9z/ve/72p/Xvv89//bZw/f+7j/f9/P8fM9rWt9uc/Pvnz1wffdd8e8e/PFvfqy19+S+q3t2/7d97Otuf//f7tnm3+fzb/vkf2PrP/4978PtX07r/z79+Pe9+Ad+jd16T+65vvXX/NR7/tvP9dD78PM9X3nfNW//33MpFJ4A4HOKTwCMQsA9i2HL01shNwAAMLPTtHmI6RiAYQwv0hcAZuZIOwB4mKPuADg0Afc8HGUAAADMxvDLbBxzDgCBKTwBwNMUnwDYm4B7VkJuAABgToZf5mMABgCCUngCgM3dFJ9+WCxXW53RDQAC7tkJuQEAgMkZfpmdARgACErhCQC2N5SdfkjFJw/LADxJwJ0FITcAADAHwy/zMwADAAEpPAHA7obi03DM3WX6IBsAHiLgzoOQGwAAmIzhl2wYgAGAgBSeAGB/L1Lx6Y17CcBdAu6sCLkBAIApGX7JhwEYAAhG4QkADmMILl4vlquh+HTingKwRsCdFyE3AAAwOsMv2TEAAwDBKDwBwGEND80/LJar9x6gARBwZ0nIDQAATMHwS34MwABAIApPADCORdM0PznmDqB6Au48XdZ+AwAAgPEYfsmWARgACEThCQDG45g7gIoJuLN24s9mAABgROeGX7J1XvsNAIAovgjyOt72XWuDBmQuTU5sOj1x/MgD4R+3/PYwt5tj7t41TXPWd+21dwSgCrY75W04yuBD7Tehdn3Xfl37PYDSpQLrDyW/jL5rn2VwGQAcSMrBX7if2VoMf3/ou9bzIAAULkrhCShA37Ufm6b5uOGV7vWwkTYqHK991d3//4e1DyC3KWLBPl6kB+qXfdf27iRAXCngfu0tztqJkBsAABiBZ8H8GYABgAAUnoCQ0gaduw8sTxZM7myhWt8adbNVSjmKfQ2/pt4vlqvh1+fLVAQEIB4BdxmE3AAAwMHY7lQMAzAAEIDCE8CaO1uoHn3YSWvzm7Vi1D+vFaKUonjK8Ovnp8VyNRzLeuFuAcQROOC+SK8r0jF9Qm4AAOCQIg6/DMPF79Kx7ZEYgAGAwik8Aexo7YOxex+K1rZF3Xy5KUQdB/ugkN0Nvw7OF8vVn2x7AgglasD9tmma/wn4+oTcAADA3gIPv3xnAAYAyJHCE8BI7myL+kzaEHWUClA3ZagT70eVbrY9DaWnJ49eBCBfkQPu4cjgxXI1hNyvhNwAAACfiTr8cpGeB78zAAMA5EThCWAmax+q3Sq4rG2GOlGEqsrwwfH7xXLVp21P17XfEIBChQ24m1/+/iLkBgAAuCP68Ev6ZwMwAEBWFJ4AMrO2GerWQ9ZiuTpO26CGh+c/OhovrEV60P7GgzZAWSoJuBshNwAAwGdCD780BmAAgAz9zpsCUIa+a6/6rn3Xd+2bvmu/7rv2903TfNk0zTfpwdNDWRzDB8g/LJar89pvBEBhwgfcTQq5hxLUfJc0mojvHwAAMLKKhl+a9HwYbTP9pwGYDK4DANiSwhNAwYZtUH3X9n3XnqUS1LOmab5qmuasaZp3aVMU5TpdLFc/pdAEgIxVFnA3Qm4AAIBfVTH80hiAAQAyo/AEEEzaBHXRd+3Lvmu/vLMF6sr7XZzh6MKh9LSo/UYAZK6agLuJHXLbrggAAGyswuGXxgAMAJALhSeA4O5sgRq2P/1eAao4wxF37x1xB5CnSgPuJmjIfbxYriK+lwAAwDgi5nUPDr80tjwBABlReAKozPBAeqcANWyAepmOwIv2oWU0jrgDyFNV251uCLkBAICapY1AEbeyPzX80gTe8mTLPgAUROEJoHJpA9S7dATesP1pKEG9tf0pW464A8hICrhr3O50I2LI/dyWJwAAYANVDr80jjkHADKh8ATALX3XXvVd+2bt+Lth+1Nv+1NWbo64e1P7jQDIQLUBd/NbyH02/iVNzpYnAADgQWn45STgHXq74fBLYwAGAJibwhMAD0rH3w3bn75J25++SUfffXTXsvB6sVwNxaej2m8EwBwCB9ybbnf6ZPi7QsC/Gwi5AQCAx0QckhhOAtho+KX5bQDm7biXNAsDMABQCIUnADbWd22fjr77Mh19d6H8NLvhaLsfFsvV88rvA8Acogbcu2wQFHIDAABViLzdadvvkApSBmAAgFkoPAGwk3T03ZnyUxaOm6b5abFcHdd+IwCmIuC+zZYnAACgIlGHX97t+H0NwAAAs1B4AmBvd8pPN8feRTu/PXdHqfTkg1mAaQi4PyfkBgAAQjP88jkDMADAXBSeADiotWPvft80zcvhq9zhSV0ulqvzil4vwOQE3PcTcgMAABUw/HI/AzAAwOQUngAYzfCg3HftsPFp2Px05si7yZwulqvLSl4rwBwE3A8TcgMAACEZfnmYARgAYA4KTwCMru/a4UPUi3Tk3dfpyDvG9WKxXA1H3B25zwCHI+B+nJAbAAAIzPDL4wzAAACTUngCYFJ9134Yjrxrmub3tj6N7rhpmh+UngAOSsD9NCE3AAAQiuGXpxmAAQCmpvAEwCz6rr1e2/o0HHvXeydGMZSehk1PxwFfG8CkBNybCRxyv8ngOgAAgHkYftmMARgAYDIKTwDMru/avu/aofT0ZTru7tq7clDP06YnpSeA/Qi4Nxcx5H5layIAANQnbfgx/LKBwAMwpxlcBwBwh8ITANnou/ZjOu7uy/TA7bi7wzlSegLYne1O2wkacg9/lgq5AQCgPoZfthNyy5MBGADIj8ITANlJx929ScfdvVR8OhilJ4DdXQa8d2MG3I0tTwAAQOnSdqfnAd/I0Z7XDMAAAFNReAIga8MDsuLTQQ0P5z+lsAaADQi4dyPkBgAAAoi43enDyMMvjQEYAGAKCk8AFGGt+PT18FDuXdvbpdITwMYiBtxXEwTcTSosRyPkBgCAChh+2Z0BGABgCgpPABSl79phAunrVHy68u7tRekJ4AmBA+6zKX6S4c/tgEVlITcAANQh6nanqZ7RbHkCAEal8ARAkVLx6StH3e1N6QngcQLu/Qm5AQCAotjutL+05ckADAAwmi/cWgBKlh6c36UQ4nXQIGJsQ+mpmehoI4BiCLgPYyhXLZarIeQ+mfLnHdlNyP0m0GsCAAB+Y/jlMN4GexZs0gDMRd+11xlcC/MYcvS/u/dAID+U+lIUngAIYa34NHzw+Cp9EMnmzhfL1VXftY4JBPiNgPtwhNwAAEARDL8cjgEYgvrv7//6r9G2lwEV+/f//I9iX7wj7QAIpe/a4UHzy6ZpLryzWxke1H9YLFfHBV0zwGgE3IeVSlaOMgAAAEpg+OWwHHMOAIxC4QmAcIZNC33XnqXik0mLzSk9AfxGwH14Qm4AACBrhl8OzwAMADAWhScAwuq79mPftV83TTN8+eid3ojSE1A9Afc4AofcEctxAABQK8Mv4zAAAwAcnMITAOEND/R9136ZHqyvveNPGh7ULz2wAxUTcI8nYsh9uliuIhbkAACgKovl6tTwyzhseQIAxqDwBEA1+q590zTNV46528hx2vSk9ARUxXancQUNuRtbngAAoGwpAzP8Mq6oW54MwADATBSeAKjK2jF339j29KSh9PQ+82sEOJgUcJ8HvKM5BdxN0JD7hZAbAACKdpo29kSTzfOXY84BgENTeAKgSn3X9k3TDMfcXfgV8KiTxXJ1mfH1ARySgHsCtjwBAAA5ScMvrwK+KX1mwy+NARgA4JAUngCoVt+1133XnjVNM2x8+uhXwoOGh/Y3mV4bwEEEDrhz2+50Q8gNAADkIurwy1kG13CLARgA4JAUngCoXnrQ/sq2p0e9XixXLzK+PoB9RQ24X2ZwDZ8RcgMAADkIPPzyru/aXAc8DcAAAAeh8AQAtj1t6nKxXB2XcakAmxNwz0bIDQAAzM3R5hMzAAMAHIrCEwCsWdv21Lsv9/rBB7lAQALuGaQ/c9/lfI07EnIDAEABDL/MygAMALA3hScAuCNte/qmaZrhy7X7c8sQBL1PgRBA8QTcsxNyAwAAczH8MpM0ABNx4NQADABMSOEJAB7Qd22ftj1duUe3DMfanWd0PQD7EHDPKJWybHkCAAAmZfglC2eFXOc2DMAAwIQUngDgEUNA0HftV0E3UOxjeHg/LffyAQTcGbHlCQAAmJrhl5kZgAEA9qXwBAAb6Lv2TdM0Xzvi7pbzxXJ1ktH1AGxLwJ0BITcAADAlwy9ZMQADAOxM4QkANpTOlv/SEXe3vPcAD5RIwJ2dqCG3YjAAAOTH8EsmDMAAAPtQeAKALfRde52OuIv4IL6LIRx6X95lAwi4cyLkBgAAppAG9yL+Pb3U4Zcm8ADMcQbXAQChKTwBwA76rn3ZNM1L9+6T48VydZ7BdQBsxHanbEUMuU9seQIAgKxEHUoo9nkq8ACMvBQARqbwBAA76rt2eBAftj1du4fN6WK5WmRwHQCbOLfdKT+2PAEAAGNK251eBLzJpQ+/NAZgAIBdKDwBwB76rr1qmubLpmmu3MfmMgVHANkScGdPyA0AAIwl4jDCMIh5lsF17MUADACwC4UnANhT37VDsPD18I+V38thW8r7DK4D4DFRA+4QRSEhNwAAMIbAwy/fpWwyAgMwAMBWFJ4A4ACGYKHv2m+Cfki7jePFcvWmnMsFahI84I6w3emGkBsAADi0qMMvFxlcx0EYgAEAtqXwBAAH1HftywhrpPf02oe6QKYE3AUQcgMAAIdku1NRDMAAABtTeAKAA+u7dvjg+WXl9/VysVwdZXAdAJ8IuIsj5AYAAA7F8EshDMAAANtQeAKAEfRd+y6VniJ+CL2JoVhwmf9lAhURcBckhdwRS09CbgAAmJDhlyIZgAEANqLwBAAjSaWnrysuPS0Wy9Uig+sAKifgLtZFwD9DhdwAADAtwy+FSQMwEV+fARgAODCFJwAYUd+1V5WXnhxtB+RAwF2gVOb6LuBLE3IDAMAEDL8U7a0BGADgKQpPADCyyktPR462A+Yk4C5e1C1PNiACAMD4DL8UygAMALAJhScAmEDlpSdH2wFzEnAXLHDIfZ7BNQAAQFiL5erY8EvxHHMOADxK4QkAJlJ56cnRdsDkbHcKI2LI/XyxXEX8tQkAALmIOGRQzfBLYwAGANiAwhMATKji0pOj7YA5RPx9p6qAu3GUAQAAsKW0QSfiFp3ahl+aoAMwxwZgAOAwFJ4AYGIVl54cbQdMRsAdji1PAADAphxtHoQBGADgMQpPADCDVHp6WeG9d7QdMBUBdyBCbgAAYBOBh1/OKh1+aQzAAAAPUXgCgJn0XdtXWHo68uEuMLbAAffbigPuRsgNAABsIGLu9LHv2ncZXMcsDMAAAA9ReAKAGaWworbS02kqIwCMJWrAXeV2pxtCbgAA4DGRh18yuIa5GYABAD6j8AQAM0ulp9qmtM4zuAYgIAF3eEJuAADgIbY7BWUABgC4j8ITAGSg79qXlZWejhfL1WkG1wHEI+AOTMgNAADcx/BLFQzAAAC3KDwBQD7Omqa5quj9eL1Yro4yuA4gCAF3NYTcAADAXYZfgjMAAwDcpfAEAJlID+1fB/wQ9yFHjrYDDkzAXYH052XEEpiQGwAAdmD4pSoGYACAXyk8AUBGKiw9vUihFMBeBNx16bt2CLk/BnvRQm4AANiN4ZdK2PIEAKxTeAKAzPRde5WOt6uFB3rgEATc9YlYBjt33CsAAGzO8EuVDMAAAJ8oPAFAhtIH3BeVvDcnHuiBfQi465T+rIwWcg9lp9MMrgMAAEpxGfCdMvzyiMjHnBuAAYDtKDwBQKb6rh22PH2o5P3xQA/s4zzg3RNwbyZiyP3Kn4kAAPC0NED3POCtMvzyhKADMM8NwADAdhSeACBv3zRNc13Be+SBHthJCriPA949AfcGbHkCAICqOdq8bgZgAKByCk8AkLG0ovnrSt6j4YE+4lQeMC4BN0JuAACoTODtTmcZXEMRDMAAAApPAJC5vmuvKgk7joIWF4CROL6ARsgNAAC1ipghfei7ts/gOkpiAAYAKqbwBAAF6Lv2YvifCt6rF7Y8AVuIGnDb7rQ9ITcAAFTC8As3DMAAQN0UngCgHC+bprmu4P06z+AagMwJuFkn5AYAgKpEHX75kMF1lMgADABUSuEJAArRd+1QdvqmgvdrsViuTjK4DiBvAm7uEnIDAEBwhl+4ywAMANRL4QkACpI+CL+o4D2LWGQADkTAzX2E3AAAUAXDL9zHAAwAVEjhCQDKMzzAXwV/305seQIeIeDmIUJuAAAIyvALDzEAAwB1UngCgMKko+1eVvC+2fIEfEbAzWOE3AAAEJrhFx5jAAYAKqPwBAAF6rv2qoIPx215Au4j4OYpUUPuiEU/AADYiOEXnmIABgDqo/AEAIXqu/ZNBUfb2fIE/ErAzSZSyB2tQHbkz0QAAGqVNtwYfmETtjwBQEUUngCgbNGPtrPlCVgn4GZTEUPuF7Y8AQBQqVPDL2wiDcBEGxA1AAMAD1B4AoCCpaPtLoK/hx7ogWGi942Am02lElnEIpk/EwEAqErabPMq4Gs2/DKes4Cv6dQADAB8TuEJAMr3NuD59OtseYLKCbjZkS1PAABQvtO04SYawy8jMQADAPVQeAKAwvVde13B0XYe6KFuAm62JuQGAICyBR5+eWf4ZXQGYACgAgpPABBACkn6wO+lLU9QqcABdy/gnoSQGwAAymX4hTClV4MAACAASURBVJ0YgAGAOig8AUAcw/n014Hfz4iFB+BpUQPuswyuITwhNwAAlCn4dqePGVxHDQzAAEBwCk8AEEQKS74L/H4uPNBDXQTcHIiQGwAAymO7E3sxAAMA8Sk8AUAgfde+aZom8ofoHuihLgJu9ibkBgCAshh+4YAMwABAYApPABBP5GOSXqTQCwhOwM2BCbkBAKAchl84CAMwABCbwhMABNN3bR/0Qf7GaR6XAYxMwM3BCLkBAKAMhl8YgQEYAAhK4QkAYor8gXrE0AtYI+BmJEJuAADIn+EXDsoADADEpfAEAAGlB/l3Qd/bo8Vy9SKD6wDGI+Dm4AKH3JcZXAMAAOzN8AsjMgADAAEpPAFAXJE/WDfBBEEJuBlZxD8bTxbL1UkG1wEAAPs6N/zCGAIPwJxncA0AMBuFJwAIKn2wHnXL03Mf7kJYrwXcjCWF3H3AG6wIDABA0dKmmogbvQ2/5CPic/lCRgpAzRSeACC2s6ZproO+wn/L4BqAA0oB92nAeyrgzstZwNdkyxMAAKWLWuI3/JKJwFueDMAAUC2FJwAIrO/aoez0XdBX6Jx6iEfAzegCb0AUcgMAUKTA250uDL9k52XA12QABoBqKTwBQHwXgbc8RQzDoEqOL2BiEUtoQm4AAEoVsbx/bfglPwZgACAWhScACC74lifH2kEcUQPuiMenFU/IDQAAeQg8/PJdyuTIjwEYAAhC4QkA6hB1y9PzxXK1yOA6gD0IuJmJkBsAAOYXdfjlIoPr4B4GYAAgDoUnAKiALU9A5gTcTE7IDQAA8zL8wowMwABAAApPAFCPqB+8LxbL1VEG1wHsQMDNzITcAAAwH8MvzMIADADEoPAEAJVIH7xHfJBvgpYloBYCbmYj5AYAgHkYfiEDBmAAoHAKTwBQl4gP8o1j7aBMAm4yIeQGAIDpGX5hVgZgAKB8Ck8AUJHAD/LHi+XqOIPrALYj4GZ2gf9sPM/gGgAA4DOGX8iIARgAKJjCEwDU5+9BX7EtT1AQATeZiRhyD2VgR74CAJCjiOV8wy8FsuUJAMqm8AQAlem79kPTNB8CvupFBtcAbM52J7Ih5AYAgGmkzTMRMxzDL+WKuuVJVgpAeApPAFCniFuenlvXDGVI/63a7kRuIobcz215AgAgM4ZfyIpjzgGgXApPAFChvmuHh/iPAV+5Y+2gDAJuspNC7ojvoS1PAABkIQ2/RBxWM/xSPgMwAFAghScAqFfELU9WNUPmBNxk7m0qr0Ui5AYAIBcRy/hRByeq4pjz2XzI/PoAyJzCEwDUK2IYc+R8esie7U5kK5XWvgv4DtnyBADArAIPv7w1/BKGAZiJvf/2Xz4oPQGwD4UnAKhUCmMiTi79KYNrAO4ROOA+E3CHciHkBgCAgwu53anv2ojZWpXSlicDMNOLeJwgABNReAKAujnWDpiSgJvs2fIEAACHFXm7UwbXwGEZgJmYLU8A7EPhCQAq1nft8DD5MdgdcKwdZEjATWGE3AAAcDiGXyiCAZjZyFYA2InCEwAQ8SHesXaQHwE3xRByAwDAYRh+oUAGYCZmyxMAu1J4AgD6gHcgYpAGxRJwUyghNwAA7M/wC0UxADMbGQsAW1N4AoDK9V37MWDpafhA9ziD6wB+IeCmOEJuAADYj+EXCmYAZmK2PAGwC4UnAGDw94B34d8yuAaonoCbwkUNud9kcB0AAMRn+IUiGYCZzcvMrw+AzCg8AQDDQ3wf8ANdx9pBHgTcFCtwyP1qsVwdZXAdAAAElTbJGH6hZFEHYE4zuI57vf/2X4aTCOQtAGxM4QkAuBHtWLvjxXL1PIPrgGotlquFgJsAIobcQ9kp25AbAIAQDL9QtMhbnjIfgJG5ALAxhScA4EbEB3hbnmBe5wHvv4C7MrY8AQDAdtJ2p4hDaIoY9TEAMzFbngDYhsITAPBJ37VXwwf5we7GnzK4BqiSgJtghNwAALA5250IwQDMbGQvAGxE4QkAWBftWDsbnmA+Am7CEHIDAMBmAg+/vMzgGpiHAZiJrb79sy1PAGxE4QkAWPf3YHfjaLFcKT3BxAIH3GcZXAPzuQi4CdGWJwAADi3i8MuHvms/ZHAdzMAAzGxseQLgSQpPAMCvHGsHHEjUgDvaFjy2kELuiIGrLU8AAByEo80JzJanidnyBMAmFJ4AgLscawfsTMBNZOlIQ1ueAADgfrY7EVIagIm49dmWJwCKpvAEANwV7Vi7Y5srYFICbqKz5QkAAO4w/EJ0BmCmZ8sTAE9ReAIAbgl6rJ0tTzABATc1EHIDAMC9DL9QAwMw05PJAPAghScA4D7RjrX7YwbXADUQcFMLITcAACSGX6iFAZjp2fIEwGMUngCA+0Q71s6GJxiZgJuaBA65I5YWAQAYn+EXamIAZnpnTdNcZ3x9AMxE4QkA+Ew61i7SQ+SxrRUwOgE3tYkYcp8ulquIxUUAAEayWK5ODb9QE1ueprf69s9DTv1drtcHwHwUngCAh0Q71s6WJxiJ7U7UKGjI3djyBADAptJwmeEXahR1y1PO2c6FLU8A3KXwBAA85P8GuzN/zOAaIJwUcJ8HfGkCbjYRMeR+YcsTAAAbOk2bYaIx/MKjHHM+PVueALiPwhMA8JBoH/Tb8ATjEHBTLVueAACoVRp+eRXw5Rt+YVMGYKZnyxMAtyg8AQD36rv2Oljp6TiFccCBCLjhEyE3AAA1ijr8cpbBNVAAAzDTs+UJgLsUngCAx0Q71u44g2uASGx3onpCbgAAahN4+OVd37VXGVwH5TAAMz1bngD4lcITAPAYx9oB9woecNvuxLaE3AAA1MTwCxiAmYUtTwCsU3gCAB6UptoiPbT/MYNrgCgE3JCkkDviJLgtTwAA3BJ8+CVicYXxGYCZni1PAHyi8AQAPCXSphNH2sEBCLjhXmcBb4stTwAA3GX4BdbY8jQ9W54AuKHwBAA85cdAd+hosVwpPcH+BNxwRzoKMeJxiLY8AQDwieEXeNDLgLfGlicAsqfwBAA8JdqHtwpPsAcBNzzKUQYAAERm+AXuYQBmerY8AdAoPAEAT0kFgEglgD9kcA1QMgE3PEDIDQBAVIZf4EkGYKZnyxNA5RSeAIBN9IHukg1PsCMBN2wkash9ksF1AAAwH8Mv8AgDMNNLW57Ocr0+AMan8AQAbOLHQHfJB7awOwE3PEHIDQBANGnDS8S/Dxp+4dCiDsBkO0C6+vbP74KdTgDAFhSeAIBNXEW6Szk/pEOuUsBtuxNsJmLIfWLLEwBAtaKW3w2/cFCBB2DOM7iGx/hvGaBSCk8AwJNSGSBSIUDhCbb32nYn2IwtTwAARJGGX14EfEMNvzAWAzATs+UJoF4KTwDApiJ9cPuHDK4BiiHghp0IuQEAiMB2J9iCAZjZ+G8aoEIKTwDApn4MdKdseILtCLhhS0JuAABKF3j45a3hF0ZmAGZitjwB1EnhCQDY1FWgO6XwBBsKHHBfCLiZgJAbAICSRSy7Xw/PgxlcB4EZgJmNwTaAyig8AQAb6bv2KoVCERylEgfwtKgBtxCM0Qm5AQAoVeDhl+/6ro2Sb5E3AzATs+UJoD4KTwDANiJteVJ4gicIuOEghNwAAJTIdifYgwGY2RhwA6iIwhMAsI0fA90tH9TC0wTcsCchNwAApTH8AgdjAGZitjwB1EXhCQDYRqQNT/+cwTVAtgTccFAvA95OW54AAOIy/AIHYABmNrY8AVRC4QkA2EakB3RH2sHjBNxwIH3XDtOl7wLeT1ueAACCMfwCB2fL08RW3/7FlieASig8AQAbS8FQlIdFWyngAQJuGEXUkHuRwXUAAHA4hl/ggNKWJwMw0zvL/PoAOACFJwBgW2GmY1KpA/icgBsOLPCWp/MMrgEAgANIG1sMv8Dh2fI0sdW3f+mDHicIwBqFJwBgWz8GumMKT3CH7U4wqogh9/PFchXx9wwAgBoZfoERBB6AuczgGh7087NnEZ/BAVij8AQAbOsq0B1zrB18LuuwakcCbrIQOOSO+MEYAEBV0qaWiDmJ4RdyYQBmYu//9ucPtjwBxKbwBABsK1Lh6Z8yuAbIhoAbJiHkBgAgR7Y7wYgMwMzGlieAwBSeAICtpIfzKI69+3CLgBtGJuQGACA3hl9gMgZgJmbLE0BsCk8AwC6iPCQqPEEi4IZJCbkBAMhJxPL6x75r32RwHfArAzCzseUJICiFJwBgF1G2PB1lcA2Qi5ABt+1O5EjIDQBALgIPvyg4kCsDMBOz5QkgLoUnAGAX/xXlrqVgD6oWOeC23YmMCbkBAMhB1O1OEQcMCMAAzGyUIAECUngCAHZx5a5BKAJumJiQGwCAudnuBLMxADMxW54AYlJ4AgB2EeVIuyZosAcbE3DDrITcAADMyfALzMAAzGxkRQDBKDwBAFtLD+VR/JNfAVROwA0zEXIDADAXwy8wOwMwE7PlCSAehScAYFdRHg6PM7gGmIWAG7Iw/Hq9DvZW2PIEAJA/wy8wIwMws5EZAQSi8AQA7CrKlqejDK4B5iLghpmlkPu7gO/D+WK58mcsAECGDL9ANmx5mlja8iQ3AghC4QkA2NV/B7lzNjxRJQE3ZOUi4Janoex0msF1AADwucuA98TwC8VJAzARc4zXmQ/AyI4AglB4AgB2dRXlztlAQaXOA75sATdF6rv2OuiWp1f+jAUAyEvavPI84NuiwECpIg7APM95AGb1t79EPU4QoDoKTwDAriI9iNvyRFVSwB3x172Am5LZ8gQAwBQcbQ4ZMQAzGxkSQAAKTwDATvqu/eDOQbEE3JAZITcAAGOz3QmyZQBmYrY8AcSg8AQA0DQn7gG1EHBD1oTcAACMKeLwy5XhF0pnAGY2siSAwik8AQD7sOUJymO7E2RKyA0AwFgCD7+cZXANcAgGYCZmyxNA+RSeAACa5g/uATUIHHC/zOAa4FCE3AAAjCHi8MuHvmsN4xGCAZjZ2PIEUDCFJwBgHz8GuXu2TlALATdkTsgNAMChOdocimEAZmK2PAGUTeEJAEDhiQoIuKEoQm4AAA7J8AsUwADMbGRLAIVSeAIA9hElWDrO4BpgbAJuKISQGwCAQzH8AsUxADMxW54AyqXwBAAAwQm4oUhCbgAADsHwCxTEAMxsZEwABVJ4AgD2cRXl7i2WK1ueiEzADYUJHnJHLGACAGTH8AsUywDMxL7/ZcvTRa7XB8D9FJ4AgJ2lD2OjcMQOIQm4oWhRQ+6IJUwAgKykTSrnAd8Vwy+EZ8vTbN4GfAYHCE3hCQDY10d3ELJmuxMUKoXcZwHfvxe2PAEAjO406HCX4RdqEXUAJtsi5vd/+0vUohlAWApPAMC+ohSeTjK4BjioxXL1xnYnKFvfte+ClotteQIAGEnaoPIq4P01/EI10gBMxPwj9wGYiEUzgLAUngAAICABN4Qi5AYAYBu2O0EAfddeGICZli1PAGVReAIA9vWjOwhZEnBDELY8AQCwKcMvEI4BmOnZ8gRQCIUnAIBf/MF9IAoBN4Qk5AYAYBNRh19eZnANMDkDMNOz5QmgHApPAMC+oky7RAwDqVfUgPssg2uAWQi5AQB4SuDhl3d910b8uzBsygDM9Gx5AiiAwhMAsK8rdxDyETzg9vsNtRNyAwDwGEebQ0AGYKZnyxNAGRSeAAB+4cNWohBwQ1BCbgAAHmK7E4RnAGZ6tjwBZE7hCQDYV5SHPoUniifghioIuQEAuI/hFwjMAMz0vv+rLU8AuVN4AgD24ogpyIqAG4ITcgMAcJfhF6iGAZjp2fIEkDGFJwAACEDADVURcgMAsM7wC1TAAMz0bHkCyJvCEwBAsliujt0LCibghkoEDrkvM7gGAICiGH6B6hiAmdj3f/3Lm6DP4ADFU3gCAA4hyrF2EcsiVEDADVWKGHKfLJarkwyuAwCgJOeGX6AegQdgzjO4hsf4PQkgQwpPAMAhOMcc5vVawA11cZQBAABpI8qLgDfC8As8LmJessh5AOb/s3cvyXFcWZqA3do0T9YKkrkCIVcgagXpikHN2pJcAYEyC7OekRz7AKBZz8lcQLm8ViBoBYlcgVAraNQO2py6JEEIj3j4495zv2+S2dVlZRceEgLxx3/O/c//+Peon8EBiqbwBAAABUsB92nA11DADU97FfAZ2fIEALC7qGVxwy/wCAMwq/G7CSAzCk8AAF+50o4SCbihUsN2c9k0zWXAn96WJwCAJ9juBNVzzfnCbHkCyI/CEwAwhV+DPMWTDM4AOxNwA0JuAIBqRSyJ3xh+gd2kLU8GYJbndxRARhSeAACgXLY7QeVseQIAqE/g4Zf3hl9gLwZgFpa2PF3lej6A2ig8AQBAgQIH3O8E3LA3ITcAQF2ibne6yOAcUAwDMOv4z//49yHn8wHUROEJAADKJOAGPhFyAwDUI/h2p5sMzgGlMQADQLUUngCAKQikYEECbuAeQm4AgDoYfgG+MAADQM0UngCAKUS5t/z7DM4AuxBwA98QcgMAxGf4BXiAARgAqqTwBADw1TPPgtwJuIFHCLkBAGIz/AL8gQEYAGql8AQAAGURcAP3Chxyn2dwBgCAVRl+AZ5gAAaA6ig8AQBAIQTcwA4ihtwnbddH/N0HALCPDwGfluEXmIgtTwDUSOEJAADKYbsT8CghNwBAPGnDScQtJ4ZfYFpRtzwZgAHgXgpPAABQgBRw2+4E7CJiyP1cyA0AVMzwC/AkAzAA1EbhCQA4WvowDcxLwA3sRMgNABCH7U7AngzAAFANhScAAMicgBs4gJAbACAGwy/AzgzAAFAThScAgK+eexZkSsAN7CWF3B8DPjUhNwBQjcDDL+8Mv8CsDMAAUAWFJwCArxSeyI7tTsARhNwAAGWLWPa+HrYbwy8wozQAMwR8xgZgAPiGwhMAAOQtasD9NoNzQGjDdnNtyxMAQJkib3fK4AxQg7OAP6MBGAC+ofAEAACZEnAD/n27l5AbAKhB1OGXiIV8yI4BGABqoPAEAAD5EnADRxFyAwCUx/AL4N+5BxmAAeALhScAAMiQgBvw792jhNwAQGSGX4CjGYABIDqFJwAAyJOAG5iEkBsAoByGX4CJGYABICyFJwAAyIyAG5hB1JD7bQbnAACYkuEXYDIGYACITOEJAADyI+AGJhU45H7ddv2zDM4BAHC0tLHE8AswtagDMKcZnAOAFSk8AQBARtqubwXcwEwi/ns4lp2E3ABAFIZfgMlF3vJkAAagbgpPAACQl/OAr4eAGzJgyxMAQL7SdqfnAV8iwy+QBwMwAISj8AQAAJkQcAMLEHIDAOTJdidgNgZgAIhI4QkAAPIh4AZmJeQGAMiP4RdgIQZgAAhF4QkAADIg4AYWJOQGAMhLxOGXS8MvkBcDMABEo/AEAAB5iBhwXwm4IT8p5I5YehJyAwDFMfwCLMwADABhKDwBAMDKAgfcZxmcAbjfRdM0N8GejZAbAChR1O1OlxmcA7gjDcBcBHwuBmAAKqTwBAAA6xNwA4satpux7PQ+4FMXcgMAxbDdCVjJOwMwAESg8AQAACsScAMrsuUJAGBdhl+AxRmAASAKhScAAFiXgBtYhZAbAGA9hl+AlRmAAaB4Ck8AALASATeQgaghd8QyKQAQi+EXYDUGYACIQOEJAADWI+AGVhU45D5tuz5ioRQACKDt+reGX4AM2PIEQNEUngAAYAW2OwEZiRhyN7Y8AQA5SptHXgd8cQy/QGECD8C8MQADUAeFJwCAryJ+2UuGUsB9HvC1EXBDgQKH3C+F3ABAhk7TBpJoDL9AmQzAAFAshScAgK+uPAsWIuAGciPkBgCYme1OQG4MwABQMoUnAABYkIAbyJGQGwBgEYZfgBwZgAGgSApPAMDRUoED2I2AG8iVkBsAYCaBh18Gwy9QNgMwAJRK4QkAmMKJpwhPs90JyJmQGwBgVlGHX84yOANwPAMwABRH4QkAAJYTNeB+lcEZgGkIuQEAJhZ4+OXjsN1cZ3AO4EgGYAAokcITAAAsQMANlCCF3BGvqBRyAwBrcrU5UAIDMAAUReEJAACWIeAGijBsN2PIHbHIKOQGABZn+AUohS1PAJRG4QkAAGYm4AYKZMsTAMA0DL8AJTEAA0AxFJ4AAL761bNgJgJuoCjDdvMxaMh9nsEZAIBKGH4BSuOacwBKovAEAEzhhacI9xNwAwWLGHK3bdf7uwUAWIrhF6A4gQdgbHkCCOY7LygAAMxKwA0UaQy5264fA+FoU7Djz3SZwTkAgMDSJpGIX64bfoE6jLnPh2A/6bjl6f2w3VxlcBaAnJSak90oPAEAwExSwG27E1CyiCH3i3HL07DdKD0BAHOKuknE8AtUIPAAzHjN+Y8ZnAMgG//3f/+fYn8vutIOAADm88Z2J6BkrjIAANhfGn55GfDRGX6BukTMf1645hwgDoUnAGAKfwryFIV2TEbADQQi5AYA2I/tTkDxDMAAkDuFJwBgCidBnqISB1MScAMhCLkBAHZn+AUIxgAMANlSeAIAgIkJuIGAhNwAALuJWKq+aZrmLINzAAszAANAzhSeAABgelEDbtudoFJCbgCApwUefnk/bDc3GZwDWIcBGACypPAEAEzhWZCnKLzjaMEDbtudoG5CbgCAx0UdfrnI4BzASgzAAJArhScAYAonEZ7isN1cZXAMyifgBkIScgMAPMx2JyA4AzAAZEfhCQAAJiLgBiog5AYAuJ/hFyAsAzAA5EjhCQAApiPgBkJLIfdlwJ9RyA0AHMzwC1AJAzAAZEXhCQA4SqAPhBEnlFiQgBuoSNSQu83gHABAmQy/AOGlAZirgD+nARiAQik8AQD8TuGJYwm4gSoM281l0C1P5xmcAQAoTBoEM/wC1OIs4M9pyxNAoRSeAADgSLY7ARWKuOXpedv1EX+XAwDzMvwCVCPwAMyHDM4AwJ4UngCAY5l+gZihiIAbeFDgkNtVBgDAztJGkIi5iOEX4DEGYADIgsITAMDvfvUcOISAG6iYkBsAqJ3tTkB1DMAAkAuFJwDgWH/yBKmcgBuokpAbAKiZ4RegcgZgAFidwhMAcKwTT5BaCbgBhNwAQLUMvwDVMgADQA4UngAAfhfxAzrzE3ADVRNyAwA1Cjz8cmb4BdiDARgAVqXwBAAcy4YnqhQ44H4n4Ab2JOQGAGoTsRx9PWw3HzM4B1AIAzAArE3hCQA41rMgT1DBg31FDbhtdwL2IuQGAGoSefglgzMA5TEAA8BqFJ4AgIO1XR+l7DR+WXuVwTEohIAboIrfH0JuAOA+tjsBJAZgAFiTwhMAcAzX2VErATfALUJuAKAGhl8AqvkdYgAGoAAKTwAATWO7EzsTcANU9XtkDLlPMzgHAJAHwy8AdxiAAWAtCk8AwDGilD5uMjgD5RBwA9wjhdxDwGfzJtI1vgDAYQy/AFT3u8SWJ4DMKTwBACg8sSMBN8CTzgI+orHsZMsTAPAh4BMw/AJMIvKWJwMwAPlSeAIAjvFDkKf3rwzOQBnOA75OAm5gMsN2c900TcTfKa+F3ABQr7Th43nAB2D4BZjSq4BP87kBGIB8KTwBAMAOUsB9EvBZCbiBqUX8vWLLEwDUzdXmAE8wAAPA0hSeAIBjRLnaK+K6ZaYn4AbYgZAbAIjEdieA6n+3GIAByJTCEwBwEF/4URMBN4DfL0JuAKiW4ReAHRmAAWBJCk8AwKHCXO01bDc2PPEUATfAHoTcAEAEgYdfzjI4AxCXARgAFqHwBAAcypd9VEHADXAwITcAULqIwy+Xw3YzZHAOICgDMAAsReEJADhUlA1PtjvxFAE3wAGE3ABAyVxtDuB3zR0GYAAyo/AEABzqe0+O6ATcAH7f3EPIDQB1iDr8YvALmJ0BGACWoPAEABwqyge7XzM4A/kScAMcQcgNAJTI8AuA3zkPMAADkBGFJwDgUC88OSITcAP4vfMIITcAxGb4BeBIBmAAmJvCEwCwt7brI5VAhH08RMANMIHgIXfEYiwAVM3wC8CkDMAAMBuFJwDgEJGCv5sMzkBmBNwAk4sackcsxwJAtdLGjvOAP7/hF2AVtjwBMCeFJwDgECdRntqw3VxlcAzyY7sTwIRSyH0R8Jm+tOUJAEI5TaXmaAy/AGuKOgATsSALUBSFJwDgEH8O8tSuMzgDmWm7/q3tTgCzeBd0s6ItTwAQQNrU8Trga2n4BVhV4C1PBmAAVqbwBAAcIsqGJ4UnviHgBpjPsN2MZaf3AR+xkBsAYrDdCWA+BmAAmJzCEwBwiBdBnprr7LhLwA0wrwshNwCQG8MvAPNKW54MwAAwKYUnAGAvwT7A/XcGZyATAm6A+dnyBABkyvALwPwMwAAwKYUnAGBfUa6za2x44g4BN8AyhNwAQDYCD798NPwC5MQADABTU3gCAPal8EQ4gQPuQcAN5EbIDQBkxvALwHIMwAAwGYUnAGBf30d5YukLV2gCB9xnGZwB4D5CbgBgdcG3O11ncA6AbxiAAWBKCk8AwL6ibHiy9YZPBNwAyxNyAwCZsN0JYHkGYACYhMITALCzVAyJ8iWeIgifCbgB1iHkBgBWY/gFYB0GYACYisITALCPKNudRv/K4AysTMANsJ7gIXekv5kAICrDLwDrMQADwNEUngCAfbwI9LSuMjgD6xNwA6wrash9nsEZAIAHGH4BWJctTwBMQeEJANjHD4GelsJT5QTcAOsLHHK/aLs+UlEcAKI5N/wCsDoDMAAcReEJANhHlOtZrtMXrNTtjYAbIAuuMgAAFpM2b7wM+MQNvwBFCTwA0xqAAViGwhMAsJMUCEYphwgAK5f+eT4N+BQE3EBxbHkCABYWtZRs+AUokQEYAA6m8AQA7CrSF3a/ZnAG1iXgBsjLRdBCspAbADJiuxNAXgzAAHAMhScAYFc/BHpSVxmcgZUIuAHyk0LuiKVNITcA5MXwC0B+bHkC4CAKTwDArk4CPSmFp7oJuAEyNGw3H215AgDmEnj45cLwC1CyNABzFvBFNAADvJEQhwAAIABJREFUMDOFJwDgSW3XPwtUeLoRBNbLdieA7NnyBADMJWIJOeqWTKAyBmAAOITCEwCwi0hf0tnuVLeoAXfEKTigQkJuAGAOgYdf3qfNKAARGIABYC8KTwDALn4I9JR+zeAMrEDADVAMITcAMLWowy8XGZwDYBIGYADYl8ITALALG56IQMANUAAhNwAwJcMvAEUxAAPAzhSeAIBHtV3/rGmak0BP6TKDM7AwATdAcYTcAMBUDL8AFMIADAD7UHgCAJ4S6Yu5a+WQagm4AQoSOOQ+z+AMAFANwy8ARTIAA8BOvvOYAIAn/BDoAdnuVKHAAfdYBDhtuz6DowDMYvw99zzYoz1pu/5lKnQBAPP7EPQZ/6nt+rcZnAOA3b2RTwNMS+EJAHhKG+gJ/SuDM7C8qCujT4JdNwlQi/F9SeEJAGaWNmlE3aZxmsEZANjPCwMwANNypR0A8KC0GSfSZgUTNJVJAXfE7U4AlOv5GHJ7/QBgdlGHXwAol/cmgAkpPAEAj4m03akZtpurDI7BsoQIAOTI+xMAzCj4dicAymUABmBCCk8AwGN+CPR0bHeqjIAbgIwJuQFgXsrFAOTKexTARBSeAIDHRNrw9GsGZ2BZwgMAcuZ9CgBmYPgFgMwZgAGYiMITAHCvtutDXWdnw1NdBNwAFEDIDQDzUCoGIHfeqwAmoPAEADzkb5GezLDdKDzVRWgAQAm8XwHAhAy/AFAIAzAAE1B4AgAeEikgVHaqiIAbgIIIuQFgWsrEAJTCexbAkRSeAIA/aLv+ZPwCLtCT+TWDM7AcYQEAJfG+BQATMPwCQGEMwAAcSeEJALjP34M9FRueKiHgBqBAQm4AmIYSMQCl8d4FcASFJwDgPm2gp3IzbDcKT/UQEgBQojdt1z/zygHAYQy/AFAoAzAAR1B4AgC+EfA6O2WnSgi4ASjY+LfXqRcQAA5m+AWAUnkPAziQwhMAcFe06+x+zeAMLEM4AEDJXtvyBAD7S5sxDL8AUKpxy5MBGIADKDwBAHdFus5uNGRwBmbWdn0r4AagcM9seQKAgxh+AaB0rjkHOIDCEwDwRcDr7K6H7eY6g3Mwv3PPGIAAbHkCgD2k7U6RcgwA6mQABuAACk8AwG3RrrOz3akCAm4AAhFyA8B+bHcCIAoDMAB7UngCAG57Gexp/JrBGZifgBuASITcALADwy8ABGMABmBPCk8AwCdt17fpQ1UYw3Zjw1NwAm4AAhJyA8BuDL8AEI0BGIA9KDwBAJ/9LdiTUHaqg4AbgIiE3ADwCMMvAARlAAZgDwpPAECTvlBznR1FEXADEJiQGwAeZ/gFgKgMwADsSOEJAGgClp0aG56qIOAGIDIhNwDcw/ALAMEZgAHYkcITADD6e7CncDVsN9cZnIOZCLgBqICQGwDuZ/gFgOgMwADsQOEJACrXdv1J0zQnwZ7Cf2VwBuYl4AagBkJuALjF8AsAlTAAA7ADhScA4HXAJ+A6u8AE3ABU5JmSLwB8w/siALUwAAPwBIUnAKhY+sD0MtgTuB62m6sMzsF8BNwA1OS07XpFXwCq13b9W8MvAFTElieAJyg8AUDdopWdGtudYmu7/lTADUCFlH0BqFoa2Iq4oRoAHvPGAAzAwxSeAKBuEcPCf2RwBmaQAm5f+AJQo5dCbgAqd5o2XQBAbeShAA9QeAKASrVd3wbclOM6u9gE3ADUTMgNQJVsdwKgcgZgAB6g8AQA9YoYFrrOLigBNwAIuQGoluEXAGpnAAbgHgpPAFChtutPmqZ5EfAnd51dXAJuABByA1AZwy8A8IkBGIB7KDwBQJ0ihoWuswtKwA0AXwi5AaiN4RcA+J0BGIA7FJ4AoDLpS7KXAX9q19nFJeAGgK+E3ABUwfALAHzDAAzAHQpPAFCfqF+Suc4uIAE3APyBkBuAWhh+AYBvGYABuEXhCQAqksojbcCf2HV2cQm4AeCPhNwAhGb4BQDuZQAG4BaFJwCoS9TyyPsMzsDEBNwA8CAhNwDRGX4BgPsZgAFIFJ4AoBLByyNDBmdgegJuAHjYuWcDQESGXwDgUQZgABKFJwCoR9TyyOWw3VxncA4mJOAGgCe1bde/8JgACMjwCwA8zpYnoHqNwhMA1CF4eeQfGZyB6Qm4AeBpQm4AQkkbK7y/AcDjxi1PJ54RUDuFJwCoQ9TyyI3r7OJJAbftTgDwtBe2PAEQjLITAOzGNedA9RSeACC44NudhmG7ucngHEzrje1OALAzXwwDEEIafnnp1QSAnRiAAaqn8AQA8UW+Gux9BmdgQgJuANibkBuAKJR4AWA/3juBqik8AUBgwbc7XQ/bzVUG52BaPqQDwP68fwJQNMMvAHAQAzBA1RSeACC2c9udKIWAGwAOJuQGoHTKuwBwGO+hQLUUngAgqArKIx8zOAPT8uEcAA7nfRSAIhl+AYCjGIABqqXwBABxnQf+2T4O281NBudgIgJuADiakBuAUintAsBxvJcCVfrOyw4A8aQvu9rAL63r7OKJ+KH83bDdvM3gHADco+36sWj7IdizGd9PLzM4BwDsJOjwyzig9ReDWgD5arv+t6Zpngd6iT4NwAzbjc+DQFVseAKAmCJPdFwN281VBudgIoED7osMzgHAA4btZrwe9zrY87HlCYDSRMwv3is7AWTvXcCXyJYnoDoKTwAQTNpWEPmLLtud4hFwA7AWITcArMTwCwBrMQADEIPCEwAE0nb9s+Bfct2kD6MEIeAGYE2BQ+7IVxsDEIfhFwDWZAAGoHAKTwAQy2mwu8fvst0pHgE3AGuLGHKfZ3AGAHhQ2kBh+AWA1djyBFA+hScACCJtyok+wWG7UyBt158IuAFYW9CQ+3m65hgAcmX4BYAcRByA+ZDBGQAWofAEAHFE/yDzcdhuon0ZWbuI2ycE3ABlcpUBACwkbZ6Itn3C8AtAgQzAAJRN4QkAAmi7vg0YFt7lOrtABNwA5ETIDQCLst0JgJwYgAEolMITABSu7fpnFWx3uhy2m6sMzsF0BNwA5OYs4Csi5AYgK4ZfAMiNARiAcik8AUD5xi+yngV/HSNO2VRLwA1AjobtZhhL1sFeHCE3ALkx/AJAjmx5AiiQwhMAFCwVR06Dv4ZXw3YT7cvH2gm4AciVkBsAZhJ0+OV62G7eZnAOAI6QtjxFu2HAAAwQnsITABSqkqvsRu8zOAMTsd0JgJylkrUtTwAwj4glXBupAeJwzTlAYRSeAKBc44eV58Ffv+s0XUMcIQNu250AQrHlCQAmFni7k8wCIAgDMADlUXgCgAJVcpVdY1IylsABt+1OAIEIuQFgFrY7AVACAzAABVF4AoDCVHSVnUnJeATcAJRCyA0AE7HdCYBSGIABKIvCEwCUp4ar7BpFklgE3ACUJHDIXcOGUADyY/gFgJIYgAEohMITABSkoqvsFEniEXADUJqQIXfaFgoAizD8AkBpbHkCKIfCEwAUIn059XMlr5ciSSACbgBKFDTkflZJeR6AfES8kl9mARCfARiAAig8AUA5PqQvqaJTJInnPODPJOAGqEPE3/evhdwALCFtkoh2Jb/MAqACUbc8GYABolF4AoACtF0/fhBpK3mtFEkCSQH3SbAfS8ANUAlbngDgKK42B6BkBmAAMqfwBACZa7v+JOiGnPtcKZKEI+AGoHRCbgDYk+1OAJTOAAxA/hSeACBj6Yuonyt6jc4yOAMTEXADEIGQGwAOYvgFgAgMwABkTOEJAPL2IWBh5CGX6QtF4hBwAxCFkBsAdmT4BYAoDMAA5E3hCQAy1Xb92/E/Knp9FEkCEXADEImQGwD2YvgFgEgMwABkSuEJADLUdv2LoAHhQz7a7hSOgBuAaITcAPAEwy8ARGMABiBfCk8AkJm268dg8OeKXpcbRZJYBNwARJRC7iHYjybkBmBqhl8AiMgADECGFJ4AICPpA8bP6cunWrwftptr/xyGIuAGIKqzgD+XkBuASRh+ASAqW54A8qTwBAB5+dA0zUlFr8lYdLrI4BxMRMANQGSppB3tPUHIDcBUIg6/vMrgDADkIeJ7ggEYoGgKTwCQibbrz8f/qOz1eDdsNzcZnIPp2O4EQHRRrzKIVlgGYEFBh18u00YPADAAA5AhhScAyEAKBmv7YHFpa04sgQNu/5wC8EXgkDtiaRmABaTNEOcBn7XhFwDuijoAY8sTUCSFJwBYWdv1bbrKrjZn/tmLI30ott0JgFpEfH94acsTAAc6TeXZSGx3AuAPAg/ARCwuAxVQeAKAFbVdf1Jp2eli2G6uMjgH0zl1fQEAtQgacje2PAGwrzT88jrggzP8AsBDDMAAZELhCQBWkspOvwScgnzKteAwFgE3AJUScgOA7U4AVMYADEA+FJ4AYAWpIPJzhWWn0dmw3dxkcA6mI+AGoDpCbgBqZ/gFgIoZgAHIgMITACwsBYK/BLz+axfDsN0M+R+TXQm4AaickBuAmhl+AaBKBmAA8qDwBAALulV2OqnwuY9bnc4yOAfTEnADUC0hNwC1MvwCAAZgANam8AQAC6m87DR6l74UJAgBNwCEfd8QcgPwFMMvAFTNAAzA+hSeAGAByk6fQsOLDM7BtATcAFRPyA1AbQy/AEDo9w4DMEAxFJ4AYGbKTp+usnuVwTmYkIAbAMK/fwi5AXiI4RcAMAADsDqFJwCYkbLTJ66yi0nADQCJkBuAWhh+AYAq3kMMwABFUHgCgJkoO33iKruABNwAUM37yBhy1/y3LAB/ZPgFAG4xAAOwHoUnAJiBstMn41V2P2VwDqYn4AaAO1LIHbHofZ7BGQDIQNr0YPgFAOp4L7HlCciewhMATEzZ6YtXw3Zzk8lZmIjtTgDw5PtJtL9/XrRd/yKDcwCwvjeGXwDgjwJveTIAA2RN4QkAJpSu/PhN2an5OGw3QwbnYHoCbgB4QCp7vw/4fFxlAFC5tOHhZcCnYPgFgKlEHIBpDcAAOVN4AoCJpLLTLwHLIPsap1nOyjoyu0gB92nAhyXgBmBKF7Y8ARBQxPLrR8MvAEwlbXkyAAOwIIUnAJhA2/UvlZ2++MlVdmFF/HBruxMAk7LlCYBobHcCgJ0ZgAFYkMITAByp7fpx480HZadPzobt5iqDczCxwAH3qwzOAEA8Qm4AIom63ek6g3MAEIgBGIBlKTwBwBHarh+LTuee4SfDsN1cZHAO5iHgBoAdCbkBiMJ2JwDYmwEYgIUoPAHAAdquf9Z2/S9BQ79DXNuUE5eAGwAOIuQGIALDLwCwBwMwAMtReAKAPbVdf9I0zT/HL3w8uy9+Sh/kiEnADQB7EnIDUDrDLwBwMAMwAAtQeAKAPbRdPwZ942an557bF2fDdnOVyVmYmIAbAI4i5AagZIZfAOAABmAAlqHwBAA7arv+vGmaD03TPPPMvhiDwotMzsI8BNwAcCAhNwClMvwCAEczAAMwM4UnAHjCGPK1XT9eYXfqWX1j3Op0ltF5mJiAGwAmIeQGoESGXwDgCAZgAOan8AQAj2i7vm2aZiw7nXhO3xg/rP2UPrQRl4AbAI4UOOQ+z+AMAMzA8AsATMYADMCMFJ4A4AHpCrufXWF3r5+URmITcAPApCKG3Cdt10f8WwGA36/zj8bwCwCLs+UJYF4KTwBwR9v1J66we9SrYbu5zPh8TCPi1gYBNwCrEHIDUIq0sSHi1gbDLwCsJeqWJwMwwOoUngDglrbrx5LTL66we9BYGPmY6dmYSAq424DPU8ANwJoihtzPhdwA4bjaHAAmZAAGYD4KTwDwe8HjWdv1v6StNq6wu9/lsN28yvFgTE7ADQATE3IDkDvbnQBgNgZgAGag8ARA9dquHzfZ/BY01JvKVdM0P8X4UXiMgBsAZjWG3NEKuEJugDgMvwDADAzAAMxD4QmAarVdP34583PTND/b6vSo8cPYT+lDGfEJuAFgJunvqYglXCE3QOEMvwDA7Gx5ApiYwhMAVWq7/rRpmn+O/9U/AY8aP4D9qCxSBwE3AMxv2G4+2vIEQIYillcv5BkA5MIADMD0FJ4AqEra6vRL0zTntjrtZNzsdFXAOZmG7U4AsAwhNwDZCDr8EvVLZQAKNmw3rjkHmJDCEwBVaLv+Wdv1b5um+S3oBps5vBq2m8t4Pxb3sd0JAJZjyxMAmYlYWn3van4AMmUABmAiCk8AhNd2fZuur/NH9+5epS/iqEfEfz/e2e4EQMaE3ACsLvB2p4sMzgEAf2AABmA6Ck8AhHXr+rqfxz+4vdI7e6fsVBcBNwAsT8gNQCZsdwKA5RmAAZiAwhMA4bi+7igfh+3mbcHn5zACbgBYR8iQe/x7PINzAPAEwy8AsA4DMADTUHgCIJS2609T0ck0wf7GstOr0g7NcQTcALCeqCF30zSnGZwDgKedB3xGhl8AKIUtTwBHUngCIIS269u2639LYZ2J8v0pO9XLdicAWFfEkPu1LU8AeUsbGE6CvUyGXwAoRuAtT26QABaj8ARA0cbtNG3X/9I0zc9pmpz9KTtVaiwK2u4EAOsKGnI/s+UJIHuGXwBgfQZgAI6g8ARAkW4VnX4JWNhYkrJT3VxfAAB5EHIDsJi03Sna0JjhFwCKYwAG4DgKTwAURdFpUspOFRNwA0A+hNwALMx2JwDIhwEYgAMpPAFQBEWnySk7IeAGgLwIuQGYneEXAMiLARiAwyk8AZA1RadZKDtVTsANAPkRcgOwEMMvAJAfAzAAB1B4AiBLYyGj7fp/KjpN7p2yEwJuAMiWkBuA2Rh+AYA8GYABOIzCEwDZGL8Iabv+tO3635qm+dA0zYlXZ1Kvhu3mbaCfhwMIuAEgX0JuAGZm+AUA8mUABmBPCk8ArK7t+udt148Fp7HodB6wjJGDV+kLNBBwA0DeIm7jFHIDrMzwCwDkzQAMwP4UngBYTbq27pdUdHqZ/vhlWmP496OyE42AGwCKMGw3l03TXAZ7tYTcAOsz/AIA+bPlCWAPCk8ALCptc3p769q6F16B2XwuO0X7wozDCbgBoAxCbgAmY/gFAMqQBpcNwADsSOEJgEWkbU4/p21Ob1xbN7urpmn+Omw3V8F/TnYk4AaAcgTe8hSxfA1Qgoi/f88MvwAQlAEYgB0pPAEwm7brT9qu/9B2/f9L25xaT3sRl2mzU7T7vjmO7U4AUJaIIffpuPE1g3MAVGPcsh1w+OXa1f0AROWac4DdfedZATCl9AXGuEnm77Y4reLjsN28qvDn5hFt158GDbjfZnAOAJjFGHK3XX8Z8ArosYTt71WABaRNCq8DPuuIpWAAuO1dxM+Cbdd/NKgNTMmGJwCONpacxkJF2/X/dGXdql4pO3FXCrgjbncScANQg4jvdy9teQJYzGnaqBCJ7U4AhBd0y1PjmnNgagpPABzknpLTedM0J57mKm7SFXYCP+4j4AaAQgm5ATiU7U4AUDwDMABPUHgCYGdt15+0XX/edv1vSk7ZuGqa5q/pyzD4hoAbAEIQcgNwCMMvAFAwAzAAT/vOMwLgIaksMd4T/bfx/xkwKCvdGPKdDdvNTe0PggcJuAGgcGPI3Xb9Zfq7PJIx5HYdM8AMDL8AQBjvAn4WHAdg3g3bzXUGZwEKp/AEwDfGLU6p3PRDwD+kIxmLThe1PwQeJuAGgFCE3ADsw/ALAARgAAbgcQpPAJVLBacXtwpOtjjlbdzm9OOw3VzV/iB4koAbAIIQcgOwK8MvABCOARiAByg8AVRGwalo45dcP7nCjqcIuAEgJCE3ALsw/AIAgRiAAXiYwhNAYKn0MP4RfOKKuuK5wo59CLgBIBghNwBPMfwCAGEZgAG4h8ITQCBt198uN43/+dzrW7zrtNXJFXbsRMANAKEJuQF4jOEXAAjIAAzA/RSeAAp1q9z0ffrPE69lOMP4x74r7NiTgBsAggoccp+PJf8MzgFQLMMvABCeARiAOxSeADLXdv3zW4Wm721uqsJNKjoNtT8I9iPgBoAqRAy523GgYyx0ZXAWgFK9MfwCAHHZ8gTwRwpPAJlIxabn6Y/VP9/679TlMpWdTDRwCNudACC4FHKP740vg/2kb9LfwgDsKWVKpwGfm+EXAPhW1C1P/zAAAxxC4QlgYekqume3NjY9U2wibXUaV7deeBgcIgXctjsBQB3eBSw8vbDlCeBgbwI+OsMvAHBHGoAZb4Zogz0bAzDAQRSeACaWrpQ6uVVq+ryt6STg5hWmYasTU3B9AQBUYvy70ZYnAJqvwy/R3g9GZxmcAQBydBaw8GQABjiIwhPAnm5dPfe50PSnOwUn2JWtTkwicMBtuxMAPMyWJwCaoNudLoftZsjgHACQHQMwAF8pPAEkt4pMza0C059ulZhsaGJKtjoxpYgB95XtTgDwMCE3AIZfAKBaBmCA6jUKT0BUd8pLoxe3/vufb/3/3f3fg7nZ6sSkXF8AAFUTcgPULep2J+8BAPAIAzAAv1N4AlbRdv0u25Ie+t/5/p7/ue1LlGBIW51uvFpMSMANAJUScgPUy3YnAKieARigelEKT2/aro/4ZR8AMVynopM/0pmUgBsAEHIDVMvwCwBUzAAMQNP8L88AAGY1fgH1V4EdMxFwA0DlxpC7aZqPAZ+CwTaABxh+AQACv3d+GoDJ4BxAARSeAGAeY2HjL8N289YVdsxBwA0ABH//FHIDPMzwCwBgAAaonsITAExr/IDx47Dd/Jg+bMBcBNwAwCdCboB6GH4BACp4DzUAA+xE4QkApjFucXo3bDd/UdhgbgJuAKCS99Ex5G4zOAdATgy/AABfGIABaqbwBADHu/h8fZ1nyUIE3ADANwKH3OcZnAEgC2nTgeEXAKCG91JbnoAnKTwBwOGGVHQ6G7abG8+RJbRdfyLgBgAqej993nZ9xL99AA5h+AUA+IPAAzAfMjgDkDGFJwDY3xjE/ThsNz+lDxKwpIhbDgTcADABVxkAxJU2HETccmD4BQCmYQAGqI7CEwDs7joVnX5UzmANAm4AoNL3VSE3gO1OAMAjDMAANVJ4AoCnjR8UXg3bzV8EcaxMwA0APCqF3BcBn5KQG6iW4RcAoOL3VgMwwIMUngDgYbeLThEnIyiIgBsA2PP99SbYAxNyAzUz/AIAPMmWJ6A2Ck8A8EeKTuRIwA0A7GTYbsay0/uAT0vIDVTH8AsAsKczAzBALRSeAOArRSeyJOAGAA5wIeQGCCFi2XMw/AIA8zAAA9RE4QkAmmYM2X5UdCJjtjsBAHsRcgOUL/Dwy1kGZwCAyAzAAFVQeAKgZkMqOv2oeEGubHcCAI4g5AYoW8SS58dhu7nO4BwAEJYBGKAWCk8A1Gb8Q3/c4jRuc/pJ0YkCRA24/bsHADMTcgOUy/ALAHAkAzBAeApPANTiOq1MH4tOr0wTUgIBNwAwgagh92kG5wCYk+1OAMDBDMAANVB4AiC6cYvMuMlpLDpdpD/yoRQCbgDgKJFD7rbrn2VwDoDJtV3fGn4BACZgyxMQmsITABHdpD/kx5LTj8N2M3iVKY3tTgDAhCKG3GPZyZYnIKrzgD+X4RcAWFjgAZhzAzBAo/AEQDDjNqdXqeh0JkijcAJuAGASgUPu10JuIJq0seB5wB/N8AsArMMADBCWwhMApbu7zemja+soXQq4TwK+kAJuAFiPkBugDK42BwAmYwAGiEzhCYBSjdfU/TRsN/9mmxMBCbgBgEkJuQHyZ7sTADATAzBASApPAJTkqmmas6ZpxpLTWHYavHpEI+AGAGYk5AbIm+EXAGByBmCAqBSeAMjddSpKjFfW/XXYbi5cWUdwAm4AYBZCboB8GX4BAGZmAAYIR+EJgBxdpz++x4LTWHR6qyxBDQTcAMAChNwAeTL8AgDMxgAMEJHCEwC5uFtyOhu2myuvDpURcAMAsxJyA+TH8AsAsBADMEAoCk8ArOlKyQl+J+AGAJYyblBNAweRCLmBkhl+AQBmZwAGiEbhCYCljYWms6ZpxoLTX5Wc4AsBNwCwpIilZCE3UBzDLwDAwmx5AsJQeAJgbuMfzh+bpnnVNM2/pZLThRIEfCXgBgCWNmw3H215AsiC4RcAYDFpy9NZwCduAAYq9J0XHYAZjBubLpum+a9hu7n0gOFJAm4AYA1jOflDsCc/htz+DgGKEHT4JeqXqAAQxjgA03b9m2B/h3wegHmbwVmAhdjwBMAUbm9xun1VnbITPMF2JwBgLYG3PEUskwPBpA0E5wFf1/dpcwQAkDfXnAPFs+EJgEPcpA1Ov47/OWw3V54i7C99+Ir4hZxrKwGgHBG3PL1su/6dv0eAzJ2mkmYkY1504R88AMhf4C1P52k4H6iAwhMAu1BwgnmcBr2+wHYnAChE0JC7SaVyITeQpTT88jrgq2O7EwCUxQAMUDSFJwDuo+AEMxNwAwAZEXIDLMt2JwBgdQZggNIpPAEwukoFp3+lgpMvBWB+Am4AIAtCboDlGH4BADJjAAYolsITQH2uU8Hpc7np0j8DsCwBNwCQISE3wDIMvwAA2TAAA5RM4Qkgtm/KTeN/V0aALAi4AYCsCLkB5mf4BQDIlAEYoEgKTwBxXKaC079SscnmJsiQgBsAyJiQG2Behl8AgOwYgAFKpfAEUJ7Pxab//vzfhfdQFAE3AJAlITfAfAy/AACZMwADFEfhCSBP17euo/sfxSaIQcANABRAyA0wD8MvAEC2DMAAJVJ4AljPVQqGbpeabobt5sprAmEJuAGArAm5AaZn+AUAKIQBGKAoCk8A87lM/5c/F5q+FJyEQVAfATcAUJCoIfd7AybASgy/AADZMwADlEbhCWB/n7cyNbfKTJ+voLOhCXiIgBsAKEIKucei9kmwV+y8aZofMzgHUJG2658bfgEACmLLE1AMhSeA313eeg6fS0zNra1MY+h/6VkBh7DdCQAo0FnTNL8Ee+FetF3/wmc7YGFvDL8AAKUIvOXpgwEYiEfhCYjibmA9Bi//uvM/u/2/YxMTsCQBNwBQlLEU1Hb9+BnqRbBX7s09nx8BZpG2O72yo0MYAAAgAElEQVQM+HQNvwBAbK8MwAAl+C5dwfTOqwVk5LE/Nq6tnAQK9D8B/966EnADQHjjlqc22g85bt/0d0wosk1y9jzoP5+GXwAgsDQAcxZwiDfazwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPD/2zu7nDiSpQ3XOZr707MCt1dgvALDCgwSEuLKsAKbFWBWQHsF2FetlloyXoHxCoxXYGYFw6zg+5RMlF003dA/EVmRkc8jofEZnSl3F1WZ8fPGmwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANA//+F3AAAAAADLMp5MB03TbMn/fbvzn71ommawwqWum6b5R/58K/+7OTzYv+KXAQAAAAAAUA/jyXRL8smtTl65ao75rfPnNq+8PjzYv+VRAgDwyXgyHTZN0/1JPGt+/3kZujXGa6kz3hwe7N/wawcAiA+CJwAAAACYy3gy3ZaC8wspNGxnvFOpQJ0KE3+1f6ZQAQAAAAAAUC7S2N6Sn1czDW5LrqQJfpdfHh7sX/MYAQDkozNAud2pM25l+ADXM+s/g5YAAMFwJ3gaT6bvm6Y5Vb5sUvM+L2GaQxqLX5Uud3Z4sP9e6Vq9M55Mv2ZutGrzy71CaKeOUoB1W0KibfR+9kWr9G/kd9H+flxMfmk+74cH+wvX+vFk+tOgsLRTeuIwnkzfNU1zrnzZj4cH+8cL/j5Xa7/y52lZ+P09o7zuuX83xpPprhSdtzMVHVblRtbqb7JeV1ukIGb8F+V3VGP9/D+lz/Lo/u0R5Vh9o/XSaB+bR5F72zJkjPuLiBulOfvT4NLHhwf7Hw2uq47m+ibcyu+/qIYz++9icuWwfXyeDi9LFEkovr+pSbiz6UUM1pNrWU+KcvGpZT2RPXS7k2fmEDctS4pBvuQWQBnFWcXHpUbxVi99ofFketQ0zYXBpZ/nHgQL1g/IxhP1eM31X2VvtkAETttO64zX7R7gNR81qmuUGjNVVZ8HgNX5w9M9kw3wrcGl03VT8zpMIQmKZDBTbGv/fLdRjyfTpqM2/8G0kTndAPteEXQ8mbYB77fDg/3LWF/7AWcGCfibjnV4qVjsRWeF35NNOUrrXNTGcKlI7JVETq/ln95pp3/vPqvsnb0UqQEAZG87i+Y+Z5iXl4xVkyddtwjBkwHpOfs8nkxfctQQFMTX8WRanFCvArY6vxvWEweIcGVX6kMeB2lattua4HgyTfFcqgF+yvCOjyTWWuW4vqfYHU+mJ4W/A0cG1/zQ0z2xjB2pq4FbCqoztk6D78aT6a2s/18q6AWl7/w5iX4cfBYAADX+6+xWvlMO9Lu8lc0WwDNbktwlZ5nvyX1nPJleiOMG5GNL1qNUgP97PJmeS7EmHDJRrt2kOyr5fskUlvbn/8hRXHekZ8Niwg1WJO0r48k0Jbh/i+ix5H1mu7Nv/s2+CQCZiTjtbJmXF4fEtRYNuMRQYs9aGYpIgecNSmEgz6xnAUetbLGe9E/a08Rd7afkaCW9K0OJgdp67Dur50kEOB+UL9sOfBeJkeD+VsRlWTGqK7YUXXOFuCQ3Iqn5llhnHEi+F74XJGxTnweAaLgRPGWYIi066IdqGc4EWxckNdlp146fge+/hfNQyc0/i8/+yeCapYLoqSdSrCVF258yzRNRFNQtUvxfEnUhfgIAY44iNb5xd5qLdVxb+xEhiBSgNBA9+YX1pAckzzySPPPC4CjJPhiKYOunYePbQohT8sC3heA+u7uT3H9iR6gGGaj8KkevRRjkmO0FRdjT5kF9HgBC4cnhKccUKS5PUDJtEzcFW18DB1ueae9/qOMxxeVJuwBQ5MSR0RTWFedCPyA9H+fOPlNYpAD9vjNlW5NwdrcjGuZoYwCwItKedo6702+M3Z1akstT7cNZiBSgNBA9+WUr2L7sGqmhfBehU8Q8s9v4fq+5T4kQR/tY2yIHviO5O8n9t34XcHmC3hFHp68yUBlWFCTx3ueg7xyiJwAIgwvBU8YpUlyeIArbEmxRYOuH0/Fk+j1YQV7bSrsp1B3gjcE1LRy0IvCu8iNcsiD3+KdMANbcREzf/ZWDzwEAMdmOMIyQSdxTGrkm6E8R+yB6guJoRU80nf1BA88YaXRHFjrN41SET5qxkkW9yKKuZc2uQb3iY0/uTrlqobg8QS+kuCcJgMTRqZaB/F0L4asTiJkAIAReHJ5yNuFOKUZAILblbHlcK/KzJfc+iuBsZOTyVEwSII1K7UQNd6fHuUD0ZENam2TS6gKnDgCALERoOtA46ZBZAMZw1r9sSfMEoBQG4iZKvO0PGngGiHvwuazVNQ5gDqSOoSJ2PDzYvzFweRoWWGexiEEtBjufIscJJi24PEF2xJX2uwiAauRU+kHRhF7ETABQPL0LniQwy13Yo5AL0Wgdh3B7ysswyhSyTD1pFwNKa9xY7A24Oz0NoidlRAT7vaJJKwAADxTt8oS701xyH4nEEfz/skXBHQoDdzK/0MBTRGqOXxHo3tEOoGo0/S3qRsX0PqQepC3c+ShismxkdndqoccFWRCx62eOP7+j7QdFMyA4oj4PACXjweGpj8AMBTxEpC2yEZjkZRBoCtnC5amIxg3uTr2D6EkBKUB8pegFANAbJa+/7B0dJDbMPbmMy9NvEClAaSB68gvriQKSr9fq6rSI1uFto6Y3Lk9hhg9zuju1HDH8DNbIM1azq9MikgFBNJdP6vMAUCy9Cp56niKloAsRGRCY9MJWBFV/5S5PbwyuibvTarB2bUCnAIGrEwBAfxTp8oS701z6qhfg8vQbRApQGoie/HIU0IkhG5Knc1T6Yk4V9iuL+lFut6GVEYcs3J02I7cjKVREx9kP84j57AaM/ajPA0CR9O3w1KfoCJcniAyBSX5Og6wpFi5PFmIiNYyafLg7rccF02mrQwECAMAVJQo0EJV0MHL+XBZcnu6D6AlKA9GTX06pk61OR+wEj7PRfmXk8rRVgBDfQiRUi7tTS9HHaoNfOrVGYprHiRj70VsEgOLoTfDkZIoUlyeIDIFJfopfU4xcnrxbaUexz47CV0RPy0MBAgDAHSUdIdK3uMcrfcf0uDzdB9ETlMYWAhG3UCdbAcROK7PpfmVRR3JbpzSKQWtzd2qhxwWqUGtcGURPAAA906fDk4dADJcniM45woGsRFlTLFyeXCbfuDu5ZIDoaTkoQAAAuKWkpgMNkg5OBGC4PD0k5VncEyiJXYR6bqGBtwRy1BjP8OqsvV8ZuTx5dv+JMnzYp7tTCy5PoIbUyqk1rk5EwfsFawsAlEIvgicn7k4tFHghMikw/cyEcFZ2S/8Clbk8WXwm3J02B9HTE8i6fuGsAHHV+RnJu7Do57Lz/806gQkAkIEiXJ5wd5qLl/oALk8POUekAIWBO5lfED09guThXp7d25k880pEQaM5//7awedtZL9aN76qwuVJnjHcnXShxwUbI8/0Z0e1xtl1/lLWydl/72XwOAne3zv4HJp8pj4PACXwR0+f0VMAlgoQZ7kDYoCMDOWdO+GmZ+GNFF5KZyRJu2aC89ZgWm1tjAoTuDvp0Yqedg4P9r0ULj3xWaaH+uBaigk/klhJ65kXQfxQvtcz+SeNeAAolVNPcc8CaIx0cCYAa12eohXMNyWJFNKAhvd3C6DlSJ7ZY+6IO9J6cnt4sH9Z+42YQ1+DNSmv/Cb55s26dQCp9WzJzwvZ23O7sacG8XMZKFya1J8YT6YflYfzkvvP0Fnvw0IkVKu7U8udyxM1SdiQ055qjWp1Rsnphp31P/f3OR1PppH6A9TnAaAIsguenLk7taSNnOJDXeQOOIY9JNdd3o0n0y/OAq2dnJ+nU/BI/3xlGPBupb9r1aKGN9LnH0+mH5QbYVvOkm+LwgTuTrq0SdVLhMm/EYv8nA3ZW5mi+iKiPpP1TX7HN7N7dGf6s69iNQDAOiSXp3eHB/suhfC4O83FmwAsuTyNSs8rDED0BKWB6MkvaT1ZW1gTEXGmyNUcvhVx+DdN4Znsm/ccP6QfsStDijm+X+vIvLfGf3tm0Dtx0/sw6g3V7u7UcmrU83hQp8nAQPFdvXXkAOcWyQ9zHiHd1hkvNfOd2b6DvKtp/X+d8WSOC6llR8njED0BgHv6cHjyOEWKy1NlHB7s7/TxjTvuFd3Gba5JEKukpwg6BY9GAuo2kD81aPZsBbnXFi5PLp5D3J2Koj2ac4eG3699JFcsldbKT31PPUsy/Suh7gigchWrAQDWJU13fnS6f3HMUgenAjBcnhaD6AlK40jchHDe9gUNvA4Zc80ryTOzreFS8081rpHs+W8yDGTvrjP0Z+Ty5Kn3YfGM9TF8eO7I3anFxOVJ3tWsMZe8p1+VLnfdVy+oMHLkh2kN+iAixSw5svw9d8+w7HNvZX21fH+HAfM4YiYAcM1/c344p+5OLdj5gzkpsUxJx+HB/vvDg/29w4P9P2Xa56NMG1iyvcEZ8iGR38WOQdIW4j5LQvBB+bJensNd3J2KYkuSKm/FpD7IcbxAWhOfyz7l7oiHlFgnx5TDg/2X6XPKka0k2wDgkUHmKdmlGE+mR7jlPcBrPeBU6ijwkCR6yjWlDaDBO1l/wRdtA49BCvtmd2p0pxxzp0/BqtQCjyWXtB5aW/eeWtSXeo91Ark70eOCUIi7n2XOkXoMSXT5XOp5vQwESW/uRNZ/ayfmiHkcMRMAuCWr4EmU75poBv9HiEGgD1IzuZNonxkLn0h65nOifN+faX64nhkZPJMeLJ+13wXcneypXvSUwX0iPcPJcvm4FNdLKVa04qeXmQTEAACr8Nbh3kVO0MFgf9WOn/l9LeaCgjsUxgWiJ5dU38DLkGuOJNd0M1AjueSODKJa5ZDDdd55yce1RWFHDmJSi/Wvj+FD7dhM8zsw8AwrkeF4xrbW6MbtKAmuRPj00niAMmIeN5B4lqFkAHBFNsGTBFqa03cfZZPUbMhRSITekEDrvQRaVsKJbSaEH9KxNtUizD02cnna7fM5NHI1wN0pD7WLnizjlBOZtC3WKUmcn7oCYo4qBgAPuHJ5wt1pLpr7663sQZrx8xE53EKqFylAkSB68knt64lVrpn2xZRnnng9ol5EWJZN73XvrUWdqbeY1EhUEcHd6YoeF/TMO0Mn+TOpNbqsz0kN1OL0j5aoeVzt9XkAcEhOhycr5btmIREFPPROZ8LISkDhwV3HIz9qvwGPYOHy1GfyjbtT2VSZVBlO3LYFaGsr52y0AuJkld00zTHCJwBwgCeXJxogHUR0oLm/fpCGLi5P+ahdpABlgujJJ2k9+VxhrrllnGu6r5dIM37HSPQ0XOcIViOXpz5jUgtRRSR3J1yeoC+sekXHnlydFiE1xGND0VPUXhyiJwBwRRbBk0GTrqve1z66hEIiuEACwmODz6LptBYJGuILMHJ56mXCQYpMuDuVT0qqLir7zm8MrllMAXpdDg/2P4rwyfrIWACAx3Dh8qTo7hRpPdV2d7oTEEv8rHlsDy5Pj4PoCUoE0ZNPhhU28CyasW2uWYyDsOzdVqKndfN57VpcnzEp7k4P+TVAmWoXyrXp2mpmsAYSh1jsd8fyTBeDoegpcqyH6AkA3JDL4cnsXGODRjwKeHCDBIbagdaQQjCsgYX7Sx8CU+0CC+5OT2PVFE1HI1ZRwJHE0SJBPi75CLtVEMenvXI+MQA44kqp+XDa85G+aS85V7iU9lHQvWFwvN+HmeN6tEXxkYazLOJDRE9giVVOc8EzuxFWv5faGngWg5FF5pod0ZP2s7W7zvMk91C75pTdbcRIVBHJ3WnR/96EIaJaWILXBjdpVJrYqUVET9pr7mAdlz8DiJkAIDTmgidjd6cW7OIhMicG7kOI+mAlpOijnaysVfBZF6MjwXB3epoPxmeh1yB6skiM0zn6ms4TAACR0drv+8wztY4RSfv6PwrX8YD27+NevGNwFE0klyeLZnIjz/gFBXcw4MSwUYRQb32ujZzRm1oaeNKE1f6Oo5JzTal/WQzLrJvXa9edBj0IYdRjrkjuTi0GLk/0uGAhsr9p1xuvDw/2Twq/63sGMZ+FsGxVrGMmXOUAoFdyODxpB1afZv8FLk8QGXm+tZNbD0GWNzgi4mnUiyyZrbS19yPcnZbE+Cz0GkRP2mv2dQnn6AMAeEGx+dDXkb4DpWn+WyPXz+wYuDstarzh8jQHcaywcl5kyhgsuDEW6iF6WhPZoxE9rc8r5evdRBgMk1qPtmhrrbxePot27SlbPGEQczVB3Z2e+vfrgMsTPIZF/9NqP86GUS/Og8NTGzNZrZ/VnMQAAD75w/JTGbhpPNZcHkkRVysJPTVIJgDWIgUj48n0VDFBpJD2EO0iTzhSE2c8mX5Unmh6O55MRzPHf6gjxWPcnXokiZ7Gk2ljdDRbaiC3wqqIaCfGpU9bgT7PChb7P3PwGaAOzpSmFk97KASruTulmE3289LJ0rQyiJ9TzHOW29XAglTbGU+mx0bTwK1IYcc6z4B6SEK99EylZ8vAEWfQeWarOHJaE6mZNZbrSdM0L3v7grao10kCrbsnyrn4Jvf6TPl3dSeEyXTsFO5OD7le1OMy6AGcRjmOGtTR7oV8jBLDHB7sj8aT6VvF9zA56215uD9pAHY8mT6jPg8A0bB2eMqlfMflCWpA8/keBDoOYWMMLFwjFyhLdXnScDXogrvTGmRwegrnWmQQi/DswjyOpJFT4g8Tq5CFUl2ecHd6SEZ3pxZcnhaAMwuUhjSqcHpyiPV6EtG1QNZHzeftNpOAJguyt2u6PK1diy3V5UnqGbg7PeSpGv+DE042AJcnWIR2vVGzd+UB7e/jJr7jJAYAiIiZ4Cmzu1OL9iLNOcfgCW0rZQRPvws82hOafyleyxVS8NFea99YfkeDSawGd6f1MU6qTgMWcrQT4mgFCACAnGjt/znzTFV3J4XreCDbYFZjEz/3cjSiFYieoDQyiZ54ZtdA1hMrcW7EBp52rhnRRUZTeNJseM+161DDDMPeuDs95GYJYeBIeY+hxwXz0NwDrgM6VGrvaS+Ur7cRiJ4AIBqWDk9Zi4iNTSERlydwgzzfmkld9c/2eDJNrk7fDYo80S3oLYosliIV7f0Ih5wNkaTK6j25CCZ60kyI08SttngWAKAalF2ezGNxadDg7tShB3enFu2GaajGVQbR02eja0OlIHryy+HB/gkNvKXRjkW09zoPaNd+1q4/lubyZDAM3/Q0fHiufL1lelzaJ5ng8gT3MMhFw63/8h5q1q7dOXhmED1pr58AAAsxETz15O7Ugl08RCa6kEad1OhJa1LnJ51TnAQRf0vhW3s6+ja6GMbI5clkrcXdyTU7iJ6WQnONQuwEALA5J0r3MEeeeYq70wOyD2Y1Nk3KLKK5nBiLnraZMgZtRPSEO5lDcC1Ymv8pXus2oLtH2/DW3L83HWjSrkdZDntHcHdK92ZX8ZLLuDu14PIElmjHF1F7IV8Ur+XyyGLjmOkdYksAyMUfRn9PL0XERhrx48n0o2KDOwX+uzgigBN+KCZar3r+Sql41/NHMKGWteJMWUh0N220QuK/LNpBNe5OSqTC4Xgy3ZEjJS2SviR6agyeqdxo3psfOT67NGZcJvLCTe5CKQDEIeWF48n0SmHA567BZBVXKIq+05r5XuE6vdOju1PLmfJg2Gm05kKK28aT6Qs5ilGbI4kNrQQqUCGyJ6RnykIA04qedgKJTrOR3nWpOVk02qKsJ6rHGSleyxvfFPfvjUQGKW5UikO7qMcTEodGcHfqs8eVamYfFD+DVd0VykS1ZhdR8CpcKb6DbkXsEjNZrNtNoPo8ADhH3eFJjojqy92pRTsAxnoPvIDDk38iWng/oASXJxFdaBzj0gV3J0WkcI/T0+NoJsS59pAtEbJ5/WG6CAA2RSsesJy01rp2pNhH+36vdNSIgctTyCP4OY4KSiPDkYw4Pa1JBqcnC3FmqXwL/N00h2U0hNcWLk/a7vdR3J0046xV3J1acHmCEog8GKy67histZrsUZ8HgJKxONJOWxy08nnFBo14zjkGLzDV55va3H+0iyxD5abNO2WxCO5OBmQQPZ2PJ1PPbkM5QTQLAKCAonDFRLCi7O4UYhJTmtKaBearNSeZOYJ/CTiOCkoD0ZNfjNeT88LrxZr7YmQHXVeCJwMBdaMZTyjGoV2qcndqkXoZPS6w4JniNcOu/wZCS7eCJ4aSAaB0VAVPBhbxNxscJUchEQByU5X7j2eXJ9ydysI4qRpIg6A40ZP2Z+YoDAAAVTy7POHu1EHiwt6bVg0uTyuB6AlKI4PoCff59TmhgTcXBE/L4XFwSDtGO1J0HsHd6SGbDBGsbAbwBOcIaEF5/f8r+A2tZngU0RMAlIy2w5OLImLzuxGvWUhEAQ8AjzGq1P3Hwkpbo6iwi7tTWUhSdWzkZFeq6IkiFACAU5Rdnna1vqXsdbg73ceb66d24yrscFYG0RM1HlDFWPSEUG9NaODBJngcHPLq8iRCGtydHrJ27GcwbDqQ2BgAlqOq4dFMMRMnMQCAOmqCJyN3p02DOVyeACAH17W6/zh2eXIjwIXlkaNhdhA9mRB54hYAoC+04gNN1w6ta0Vyd3Ll+iku1pr7cliXp8Ze9IRIAdSRWibuZM5A9AQB8ejypC2kieDupHEsnfbv+i0uTwCwiAwxU831eQAwQtPhyV1z2WDaAZcnAJjlzpWm8qOiLFye1i6yGAhwcXfKCKInM9yeEw8AUCqK+aZKnqnYoMHdaTFacSHDWavBcVRQFBzJ6JNMoic110aAxzByeVp7P/QoMl8TdXenTWvGuDwBQG5k3dqjPg8ApaAieHLq7tRCIREArLgrlolAo1ocujzh7lQ4mURPJUyz1SykBAAoBa04wZPDJe5Oi1G5N1LvwOVpSXBmgRJB9OQTjmqBVXFeO/Dk/KMtMo/i7jRSuhYuTwD9UO17ImswQ8kAUARaDk9um8u4PAGAEdeIne7hwkpbpilxdwoAoqdf90ANilkAAPpInKDR0N4oz1Rs0Fzh7rQQ7biQ4awVQPQEJZJB9PSeB2N1jNeTkhp4mmKSyI7Cbn+XBn2PTZx/cHd6yMbuTi24PIEymuv/s+C/nKoFOZzEAAClsLHgybm7UwuFRIgCRxL5YITY6T6OXJ60CyyflK8HK2CcVG0V5PSkBQkkAIANHlyecHfqUMKxKrg8rU4m0VPoewj5MRY9nSLUWw9ZT44rb+AheFoO1b6HwefTrlut7Pwj6xDuTvfRdHdq6f13DWH4S/GLhF3/Dd6PrOuaFplET/Q9AWAjNBye3B8dJNMOmgUxXJ6gL9j4+6V1dTrRmtAJxgflr3O0SmJhUJywEODCikhSdWJ032oTPSF4AgAwQFH4nfLMlSetld2dojhbars73RjdG4azViSD6OkzU8agjYieLo1uLO5ka4JrgSovAn2XWVwLngwE1OnZ3V3xv3HfH1oCt+5OLc4cvQBaIu9zqt8tt5BTkwwx02cEmACwCX9s8h8buDvdGhYAUiNe83z7U8MJLYBFaBYQvnGXlyYFo2eIXx4nBb7jyfRKWXSUEu9lbfojFFhgDundG0+mjfI+3tKKnnacChk136nIRWjYjKuC44JXyvsOwLqkuEGj4ZzcOj6uuCdp7Y+4Oy3G5N5IjHOuKM66c3mKfiRzej9S7JZiOIMmy6ATG+LoC5ocSw3VojGYRE8NNYvVkTpGu55oN9q8ryfXinF05Ib3K8VrWdUczvrqexj0h/pwdzoqwN2p5Uz5syaXpxGDvdWhuScNkjtPyWKeR9BeF4rGOGbyXp8HAOdsJHgqQfneIoXEU8UA/M7liWICZIaGXl4uZV0K3TBQppfEW6YmcXcKTMWiJ83PsyuNFoBZvh0e7C8rLnXFeDJ9T3wEHkgF3iRUUhA9DVYRfCs2mXB3Wox1XPhBubaSYqXnitdziYiejisVKUCBGAv1GkRP65NB9HThNNf8R/Faw4gNbxFRa+YaPxSv9Yue+x7a/SHtY9uWQfs7rDq8sDQpXlceNl0p94AwaD+fu4Yivz55rfh3h8gpJGY6qXQoGQAcs7bgSaz2tY/X+p80Lay4Uf7M5+PJ9JLFF3Iggg7Nwgsinqf5hNhpNXpMvIuY4ofNyCB6OncoCPqxhp38ItLU1e7hwb6Vm2aSF8kAABN9SURBVCYAKFJg04gjoPRcnlaZtNZq0ODutJgb4zrF/5SvV81wVuXOLFAgiJ78UqlrwZWy0OMooGhCe7DCcj/J7vIkxypr9lqyC/ANHKoaqb1Yvgva6wguT5Uh9XvNL/06muBJ8krNWC1MPlH5SQwA4JS1BE+y2Gsr35sCzwxGAQ85eaP8d0W0GdUmFQtvKHCvjLrL02PrbGoIKzUXW3B3coxxUnUkDQJPoiftIvRbw+ODAUCXYWHxmnZzsDhyuzzh7jQXbXenRuLa0pzkqjmCH9ETlEYG0VMazrzmmV2dznry3eDyHht42s/Im4A1cu1arNl7aeTy9NTAlHZ/qA8BvkWPS7NGmQN6XHVyrRiHbAd0+dN+j/9Svl6vIHoCAG/8d83PY1FELJW3IgADsEYzyLp1EICmgOU/Wj9N07w0mHBprcd5x1dAGmaaTbOBNPQWEaHAAisggrQTo3uWRE8Wydq6aBdEt2UKEwD8U8y7yrpyD604Ypk8E3enDiKCt2halcjwifg5FCLs2DHIBxtyQrBAmjc7RuKHVqiH8+IayHpiNQDTNvBcrCfyHGrWBkPtPRJXaLktN5lqsdox3ULXTIn/NXOAKO5OpUKPqz6037doeZi2a3C4U0SkPm8ZM3mqzwOAc1YWPBlZxJfMoEBnKigMOUKS4+weQYpSFgIIgqv10C6yzE2acHeql8OD/ZGhc4Eb0ZMUobUbIdZFiBtZAzR/eC+hRl4U9J0RPAnSyNKIgx7NMxUbNJeB3J0QO92nqvthLHpyJVKAGHRETxYCCERPG5ChgedpPdF2/42092h/F/N4S55dzTXlsYEp3J1ikdak89pvQmV8U/66R1KnLx4DMeRtVOdN45hp19lQMgA4Zp0j7XB3egjnHIMZRkdIage0LhArzRcGIsQUXL0/PNjH2ndJ5CzwK8UG6N2k4Bwxkvb0IO5OBZGOnhP7XIsp0iO5tgfL4U/Kx12kouU7EY2pI81+1fVSiqzVOFUACCn+GBSSY7x28Bk8MZIhoU3z5tN0RN6sG4DkB1oNCSvHxKwYiOAjsCh+DkuO46jIF0ATOd5uz/pIRn5pq5PhqJbPTtaTb8o1tGGE+plR/vlF+XqLOFN+bk9nxVoSd+HuFI9UBzsLdiwZLMbinbsQMXexKOfaLdriYlcYx0ye6vMA4JiVHJ5wd1oILk9gyWeDwlfYIOvwYP/EKGBPDSdNK+saMHV5MtiTcHcqkCR6snR6chL3WKzZ50x8A5igPbXnPvaQhof2elL09KOI1D4oXW7e4IPWENIDMVXBMKE/n+ruS4bjqJgyBlUyHMn4ld/Yehi7Fmx7cFM5PNi/NHj2TkvONaXW9Nng0llqsUYuT7O/T9yd4sJ9qQTJWbXXpW05qaRkLHpxuQSvvSF7T/T6PAA4ZtUj7XB3WgznHIM6YtmofUTITQWTGntGtvAXCASWR6azNMVnwxkrbe09iWntQjEWPfW+t8uabSHk5JgLAH0sGkbecwz1Zl0Q59yR0vNw72gAZcF3iNgHd6dHGYqDQVUYixSo+4A6GURPsCYZjrfzgIUQp8hcU+IsC8e1y8zxrXaM9yv2NIi7cHfyRZhjyWApLIQ456XmH0a9uFsRF4cnen0eAHyztOAJd6cnweUJVJEAyyI4/BT9NyVFhD2DYuHdlBfixpUwcXnC3QlmMU6qPGCxdg8QPQGooy24HnqeshX3S20XqhDCfEOXJ9ydHsIk+uNUeX+MRQoA6hiLnmADZD2JPCClFa90aetnxeSaHbGTxWfOWos1cHnqimBwd4oP96cSZK2wiDsuShM9Gfbiquo3VFCfBwCnrOLwhLvT0+DyBBuTigHjyfS74ZRyFQGHFAtPDC49NLK2DomBy9O2uDzt4u4Es0hSlXUyMBcGBcuWVvTEkZ0AOvwwuI/vPBYLpYFlcbRT0cfZzaDq8oS700Nwd1qKKl2eGkRPUCCInvxyeLD/Pmo9TZ47izx6WMqAjbHY6aYndw/1AUS5T7g7xQeXp7qwEL02JYmeDMVOjeH9dQuiJwDog6UET7g7LQ0uT7A20sRIwdV3Q1vrywqOs/uFFLhHBpdOohv141sCY+HypDlthLtTLPaCNcu7WDWn2+nbC4TbABtjVbB3VSyUxpXFcR+JbwbX7AUDlyfcnR7CBPpyVHufED1BaYj4ZI9fnD+CN/Asc83v48n0vdH1N0aGf34a1mJ7EZlbuDwZHGWNu5NfuE/1oDWkM49Ux3B7WkYO44GaenFdED0BQG6WdXjC3Wl5cHmCpUnPSmpepcBPkmvrRlaNivITo+ajS7cFj1i4PClPY+HuFAhpLu9EFD0Zujy1pDXtZypGE8sArIc0Ka3e01QsPO/7/RxPpu8MxU6JPibgLVFzecLd6T64O61EtS5PTR3HUUEwJIdGqOeQqA08g7rNLMkd6Ls4drtABk8/i4u7VVzb94Cd9t5XurvTO9ydlgaXp0pQHtKZx67UGj0NcA1EiGtpPNDUnn9IzBStvgMATnlS8IS708rg8gQLSYm9CJxSsyo1iv6Wo0ByHCWUPZF0xJ5R8/G8BGtuJ3gN8HF3Ckhk0ZPRUZ1dBjLJ1wqfvBS4KLRBSVgWdN7JlHz2YqHEsV9lstuqKXQdbQJS9iStOEjjvo9wd6qW3gWTfRL5OCqICe5kfgnsWmCda27JEXe9Hqkujh4XMnhq/Tl6fYczDE1tQtY6ocRAxI6rwf2qh5HxWjGQAa6f0hvrJScRoet7Wf+tn++zWt2dZjgOfBIDADjijyU+Cu5Oq5Ncnqq1KywBadbkYuikUVttoSw1msaT6Z6BG0F7DNRLaWbB4t/B1XgyvRJ3Jk8w6R0Uee935L0PI0w8PNi/HE+mlxkKs20x8FTe3S+5j0WVIvhrA1c3AGs+GA9ADKVYeCp/l9m7KYXI9C6+ybSHh3QjPTzYH40n07cO1jJN8VWv4O60Fu1wlttjhaxJIoXxZNrw7EApJLGCPLMX/NJ8EXE9SU6l48n0LEMTOMWUSUh/I4MCX6wHNCVuaGPaXPWBSyeDp2cO15A+hnLpca1OEqYg2qgAqaEeSw3VkqGsR+dS2/wi64FZX6VT03idyXSgEfHYKNPf5Zqo9XkA8MejgidJBnB3Wp22Scgkll+8iS6sqT45kcLNiUGSP5SA7aXydSNy5uzdw90pOIGTqmN5l3IV67bl51yK0qkw+UOcWFSKlOKWN5Tf06sK92kIRIq50vBDhgbYUNyW0rt5Le/mN9nf1pqgk/xvKO9g7ncx+r7sodn0IZBIn4nz9UjDWaOahzUQPUFpIHryi6wnw0i5S3LDG0+mrzPlz0MRobwbT6a3nTzzSuLCteuYcnTeUOLZrR7qAbde+gKyhpw6GyLqw92JHtd60OOqBBlWHmU6vWYgsfhdPC6Dlt/ECWjtekZzv77Yrv997NHHDMf/BtETAOTgKYenU4NmWto0/3H429VO5lDAgxeuxb6/eiTJf2EQuN/ZYYutOSzAocsT7k4V0EmqfkaZ5ut8p+89/PX3HDWk+dJIUbqRwu6PJ67xrFNs3WLKEoJylrmZ3jZy7mIceTdvZmzp05//kj//byb3GTgoPIXelx00m26jTJlKEVv7/WqL7N54pvxdq3d5ahA9QYEgenLNXtABG22H9KdoHTh2W1HzGvFs46jetOes2f3JkVg8iruT1x6X9tAKPa66aIeVc+9p293nVtb/25mj0Gbrja9mruGlvnjmxN3PFYieAMCahYInI4v4FNBanwe+FtKE17ZsRAEPfXMrxRcQ0hokTRLtIkhKAL/hGPQkn5wUoHB3qoiZpCqK6Ola7Ka9ND2673Uui2gAt4jLU44jQR7Dy7HKy3BVyb7cp8tTJHenc4NrHntt5HRcKrSo3uWpQfQEBSKipyEOd76I2MAzdEhfh5Li2RaPze6ROBy5EAPk/MuM3J2uHfe4hjLwp0laC3b6/WaQg5mj7fpeLwZzegje641XGA8sBtETAFjy30eubZFAu53alUREOxk5kiAToC/2mMCYy97MhJgWFyKmggVIM9PDM4m7U2WIHfKOCEFDIO+TyyIbAPx7JMjMRCLMx82RH9b0GAdFcnfaNhDPf3SeM2nHrYNMR1W4Rxx6mcCGYpDYgsEdZ4iAdCdS3CcxC0O8q/PRY7NbntEPDj5KFHcnD/dyLhLTau8T2xKDQwVErJ9m4hrjgafpxEz0LAFAlbmCJ0N3J++FJIsGOJNX0BfH2GfORwKrPaPA/atMD8Fi+hYb4e5UKUFFTyMEfACuoVD4NLUJ9PtYsyO5O1U1mNXYCeXekrP8Yg9xKpSECPXIZ52B6AlE7OT5fo0c5CUR3J1KqCnS44KNQPS0Mnf3q3YH3WUx7s0BQKUscniqrojY4PIEsThG0PE4ErhbOKMMDI7HDIUDlyfEIRUTVPT0nkI0gE86zS8KOfOpTqDfQxyEu9PjeHd3asHlyYiIIgWID6InnyB6qhrvYicPLk9R3J1K6HHh8gQbg+hpaRA7rQHPFwBo80DwVLG7UwsKeCiZFCC8ROy0HHKfLBpAW+PJ9MLiMweirwIB7k4Q+Xg7pmMAHEIhZyE1C/RzxkG4Oz1OEUJ4XJ5sQfQEJYLoyScRXQs6oidi2fmceRc7dejT5Ql3p7zQ44KN6dQyOH5sPpeIndaHWhkAaDLP4anaImKDyxOUzZWInSjSrsDhwf6JwTvfyHvP1PQCenR5wt0J7pC1MtSk6uHBfkq0X9KsA/BHp5DD+/lvMWuvZgGyfPccA0E3uDs9ymVhxyni8mQIoicoEURPPpG9JeKADU3v+7Qx7XtPH+oxenR5wt0pM7IOad9zXJ4qRGoZL0XcA79JYtc9xE6bgegJALS4J3gycne6KfCYAovAHwU8WHErAdZOYQV7T+wZFbbPSQQfJXehAHcnuIcIhKKJntJz/lLeL5JFAEd0Cjk1Fwpbu3eKpXnioDPcnR6lz2NdVgaXJ3sQPUGJiOiJZ9YZQV2F26Z3CDH1hrRDpyXGtH24POHu1A+4PIEKKUZO4p6maU6oNd7lYzsliV29g+gJADSYdXiq2t2pRZIV7UIiLk9gwUdJsAmwNkAK21b23J959+fTg8sT7k7wgI49fyhkX2ACC8AZnUJhjceCjJIgEzfSfzFyFu4SRuht5O5U0rH7XbRFWrg8zRDxOCqoAoR6DgkqeroVp/Ra3Z7S7/Kk5KHTHlyecHfqCaN8A5enijk82B9JrbHEPEqDkfTiav3+ZkjMtBf06wFABn4JngzdnUotsqKAB8+k9+p5muTD1UkHw+OtBiJ6YnJ6PrkKBrg7wUICi55uRFixU3ExAsAlsu48r+QYmnYC/sTBZ/GGZRwUSejNYNZvPho0zt8yoHGfiMdRQWxwJ/NLVNeC1Ow9PNh/Xpnbx0hqsREcrnK6POV2dxoaxI63BQ+T0eMCVaTWuFOZ8PVK1v8TjrCzQ4Rk4erzAJCHrsMTRcQORs4juDzBJtx0kmuETgaIu5vFurWVjrfr/Qs6JKPLE+5O8ChRRU/N72L0DsKnuwbQSSUCEygAmZA/Dix8uhKr9x1cneZj6PKEu9PjlOruZOXKMKBx9RCOVoDSQPTkl8jriYh/nkvNJWKd8rYzdBqm0Z3R5amPmMvkGORSf/e4PIEVHeHrceBa42WnpkEvLgOR6/MAYMud4Gk8mW7h7jQXiwb5hcE1IS43HavMNrkmuDJEjoGymNpJgkeOi5iPtRgJdydYiuhJVUf49DzzRGdf3EhxOv1O/5SjtEbso+ANmZA8DvRudouCuMs9jUUchLvT45R+fyzWCYaz5oDoCUoD0ZNfZD0J6XYpIv73wRrfN/L7ijx0miPv6MPdSbvHdSv3qmRweQIzUi21M2QZof5+2zEd2KOmkR9ETwCwDq3Dk4XzSPFFViPnERTw8BhXElAdS1DVipwoVuXl2KhAeD6eTHc9f/E+yODyhLsTLI08j6EFciKuSHvLn3I+usXxOH1w3RE4tXvosRRfaFSCe2bezePCjk1om3h/UhRcDYOpa9ydHqdYd6cWQ1cGGldzQPQEpYHoyS81NPA6je/2uLuSnsN2YKYdOh1FziMzuDzh7uQEXJ4gBzJkeTdwWGA9oz22MtUy/sR0oH8QPQHAqvwh7k7awUkkN40zA1emt5UfKVMjs7/vb/LPm/aHIMoPKZEdT6YpoPoqRzxocjGeTK/5fT/AYq1tcHeCdUgJ+ngybQwmA90hR3mmn2OJCZMo85VBbKjNleyfP1IRHXEFRKMVX44n04G8j6/ln14cWG7lPUwx7SVxzcacKa67kYTeFrFhlPszkrqCZq6SXJ7OeJ8fkkRP48l0xyg/BFDHuKYBG5BiPMk1Q58AIHtJ2qtG4rrTjWc9PZPdeLZGkaBFPNGCu5MvPhjUeU7pccEsIhD0Xs9oRJB7twdIbRScUUvMBAA6/If7CAAAAACziAAq/byQf25lLk5fS4GxFQlfIRCG2uk0jHK/l12R4RXuowAAAACwDk7iWYZmAAAy0xFAbcmw5TCTCOq6W8+QPQD3VgCAQCB4AgAAAICl6diWdwvTL9YoUn/r/LkVNzUUngFWp/Nedqd2X614oVQA/Ev+3L6TiAwBAAAAwJwFeeaq8WyKYf/p/PmWxjYAgG9k4HIwI4Batc7YrWdwqgoAQE00TfP/ke+aqDVl3QcAAAAASUVORK5CYII=)

**Let√≠cia Oliveira Gobbi**

##Bibliotecas
"""

pip install plotly pandas

pip install mplfinance

pip install bokeh

# Importa√ß√£o das bibliotecas b√°sicas
import pandas as pd
import numpy as np

# Para visualiza√ß√£o
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.graph_objs as go
from plotly.offline import plot
from plotly.subplots import make_subplots
import plotly.express as px
import plotly.io as pio

# Para escalonamento
from sklearn.preprocessing import MinMaxScaler

# Para clustering
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture

# Para processamento de dados temporais
import datetime

# Para a Cadeia de Markov
from collections import defaultdict

# Ignorar avisos
import warnings
warnings.filterwarnings('ignore')

"""##Explora√ß√£o dos Dados"""

# Carregando o dataset
df = pd.read_excel('/content/Challenge3_NFLX.xlsx')

# Exibir as primeiras linhas
print(df.head())

# Converter a coluna 'Date' para datetime
df['Date'] = pd.to_datetime(df['Date'])

# Ordenar o dataframe por data
df = df.sort_values('Date').reset_index(drop=True)

# Verificar se h√° valores nulos
print(df.isnull().sum())

# Visualizar as tr√™s primeiras linhas
print(df.head(3))

df.isnull().sum()

"""##Tratamento dos Dados"""

# Calcular o corpo do candle
df['Body'] = df['Close'] - df['Open']

# Calcular a sombra superior
df['Upper_Shadow'] = df['High'] - df[['Open', 'Close']].max(axis=1)

# Calcular a sombra inferior
df['Lower_Shadow'] = df[['Open', 'Close']].min(axis=1) - df['Low']

# Calcular o range total do candle
df['Total_Range'] = df['High'] - df['Low']

# Evitar divis√£o por zero
df = df[df['Total_Range'] != 0]

# Calcular as propor√ß√µes em rela√ß√£o ao range total
df['Body_Percentage'] = df['Body'] / df['Total_Range']
df['Upper_Shadow_Percentage'] = df['Upper_Shadow'] / df['Total_Range']
df['Lower_Shadow_Percentage'] = df['Lower_Shadow'] / df['Total_Range']

# Visualizar as novas features
print(df[['Date', 'Open', 'High', 'Low', 'Close', 'Body', 'Upper_Shadow', 'Lower_Shadow', 'Body_Percentage', 'Upper_Shadow_Percentage', 'Lower_Shadow_Percentage']].head())

# Verificando a quantidade de NaNs em cada coluna
print("Quantidade de valores ausentes em cada coluna:")
print(df.isna().sum())

# Verificando se h√° valores ausentes em todo o conjunto de dados
total_missing = df.isna().sum().sum()
print(f"\nTotal de valores ausentes no conjunto de dados: {total_missing}")

"""##Visualiza√ß√£o de Dados"""

# Selecionar as vari√°veis desejadas
variables = ['Open', 'High', 'Low', 'Close', 'Body', 'Upper_Shadow', 'Lower_Shadow',
             'Body_Percentage', 'Upper_Shadow_Percentage', 'Lower_Shadow_Percentage']

# Verificar se todas as vari√°veis est√£o presentes no DataFrame
for var in variables:
    if var not in df.columns:
        raise ValueError(f"A coluna '{var}' n√£o est√° presente no DataFrame.")

# Criar um DataFrame somente com as vari√°veis desejadas
df_selected = df[variables]

# Calcular a matriz de correla√ß√£o
corr_matrix = df_selected.corr()

# Plotar o mapa de calor
plt.figure(figsize=(12, 10))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Mapa de Calor das Vari√°veis Selecionadas')
plt.xticks(rotation=45)
plt.yticks(rotation=0)
plt.tight_layout()
plt.show()

# Histograma do pre√ßo de fechamento
plt.figure(figsize=(10, 6))
sns.histplot(df['Close'], bins=50, kde=True)
plt.title('Distribui√ß√£o de Frequ√™ncia do Pre√ßo de Fechamento')
plt.xlabel('Pre√ßo de Fechamento')
plt.ylabel('Frequ√™ncia')
plt.show()

"""##Escalonamento de Valores"""

# Imprimir DataFrame
print("Features dispon√≠veis no DataFrame:")
print(df.columns.tolist())

# Selecionar as features para escalonamento
features = ['Open', 'High', 'Low', 'Close', 'Body', 'Upper_Shadow', 'Lower_Shadow', 'Total_Range', 'Body_Percentage', 'Upper_Shadow_Percentage', 'Lower_Shadow_Percentage']

# Inicializar o escalonador
scaler = MinMaxScaler()

# Aplicar o escalonamento
df_scaled = scaler.fit_transform(df[features])

# Converter de volta para DataFrame
df_scaled = pd.DataFrame(df_scaled, columns=features)

# Adicionar a coluna de data para refer√™ncia
df_scaled['Date'] = df['Date'].values

# Visualizar os dados escalonados
print(df_scaled.head())

"""##Clusterizando"""

# Definir o n√∫mero de clusters
num_main_types = 30
sub_clusters_per_type = 5
total_clusters = num_main_types * sub_clusters_per_type

print(f"N√∫mero total de clusters: {total_clusters}")

"""##K-Means"""

# Aplicar o K-Means
kmeans = KMeans(n_clusters=total_clusters, random_state=42)
df_scaled['Cluster_KMeans'] = kmeans.fit_predict(df_scaled[features])

# Adicionar a coluna de cluster ao dataframe original
df['Cluster_KMeans'] = df_scaled['Cluster_KMeans']

# Visualizar os clusters atribu√≠dos
print(df[['Date', 'Cluster_KMeans']].head())

"""##Gaussian Mixture

"""

# Aplicar o GMM
gmm = GaussianMixture(n_components=total_clusters, random_state=42)
df_scaled['Cluster_GMM'] = gmm.fit_predict(df_scaled[features])

# Adicionar a coluna de cluster ao dataframe original
df['Cluster_GMM'] = df_scaled['Cluster_GMM']

# Visualizar os clusters atribu√≠dos
print(df[['Date', 'Cluster_GMM']].head())

"""##Definir o melhor algoritmo"""

from sklearn.metrics import silhouette_score

# Coeficiente Silhouette para K-Means
score_kmeans = silhouette_score(df_scaled[features], df_scaled['Cluster_KMeans'])
print(f"Coeficiente Silhouette para K-Means: {score_kmeans}")

# Coeficiente Silhouette para GMM
score_gmm = silhouette_score(df_scaled[features], df_scaled['Cluster_GMM'])
print(f"Coeficiente Silhouette para GMM: {score_gmm}")

# Escolher o algoritmo com maior coeficiente
if score_kmeans > score_gmm:
    print("K-Means apresentou melhor desempenho.")
    df['Cluster'] = df['Cluster_KMeans']
else:
    print("GMM apresentou melhor desempenho.")
    df['Cluster'] = df['Cluster_GMM']

"""#Gr√°fico De Candlestick"""

# Preparar os Dados
required_columns = ['Body_Percentage', 'Upper_Shadow_Percentage', 'Lower_Shadow_Percentage', 'Cluster']
for col in required_columns:
    if col not in df.columns:
        raise ValueError(f"A coluna '{col}' n√£o est√° presente no DataFrame.")

hover_columns = ['Date', 'Open', 'High', 'Low', 'Close']
for col in hover_columns:
    if col not in df.columns:
        df[col] = None  # Preencher com None se n√£o estiver presente

# Gr√°fico de Dispers√£o 3D

num_clusters = df['Cluster'].nunique()
clusters = sorted(df['Cluster'].unique())

# colormap para gerar cores
cluster_colors = px.colors.qualitative.Light24 * ((num_clusters // 24) + 1)
cluster_colors = cluster_colors[:num_clusters]
cluster_color_map = {cluster: color for cluster, color in zip(clusters, cluster_colors)}

# Adicionar uma coluna de cores ao DataFrame
df['Cluster_Color'] = df['Cluster'].map(cluster_color_map)

# Criar o gr√°fico
fig = px.scatter_3d(
    df,
    x='Body_Percentage',
    y='Upper_Shadow_Percentage',
    z='Lower_Shadow_Percentage',
    color='Cluster',
    color_discrete_map=cluster_color_map,
    hover_data=['Cluster', 'Date', 'Open', 'High', 'Low', 'Close'],  # Ajuste conforme necess√°rio
    title='Visualiza√ß√£o dos Clusters em 3D'
)


fig.update_traces(marker=dict(size=4))
fig.update_layout(
    legend_title_text='Clusters',
    legend=dict(
        itemsizing='constant'
    )
)

fig.show()

# Converter 'Date' para datetime
df['Date'] = pd.to_datetime(df['Date'])

# Ordenar o DataFrame por data
df.sort_values('Date', inplace=True)
df.reset_index(drop=True, inplace=True)

# Obter a lista de clusters dispon√≠veis
clusters = sorted(df['Cluster'].unique())

# Preparar os dados
df['Date'] = pd.to_datetime(df['Date'])
df.sort_values('Date', inplace=True)
df.reset_index(drop=True, inplace=True)
clusters = sorted(df['Cluster'].unique())

# Definir o n√∫mero m√°ximo de candles a serem exibidos por cluster
max_candles = 400  # Ajuste conforme necess√°rio

# Criar os tra√ßos (candles) para cada cluster
data = []

for cluster in clusters:
    df_cluster = df[df['Cluster'] == cluster]
    if len(df_cluster) > max_candles:
        df_cluster = df_cluster.tail(max_candles)
    visible = True if cluster == clusters[0] else False  # Apenas o primeiro cluster √© vis√≠vel inicialmente
    trace = go.Candlestick(
        x=df_cluster['Date'],
        open=df_cluster['Open'],
        high=df_cluster['High'],
        low=df_cluster['Low'],
        close=df_cluster['Close'],
        name=f'Cluster {cluster}',
        visible=visible
    )
    data.append(trace)

# Criar os bot√µes do menu para atualizar a visibilidade dos clusters
buttons = []

for i, cluster in enumerate(clusters):
    # Criar uma lista de valores True/False para a propriedade 'visible' de cada tra√ßo
    visible = [False] * len(clusters)
    visible[i] = True
    buttons.append(dict(
        label=f'Cluster {cluster}',
        method='update',
        args=[{'visible': visible},
              {'title': f'Candles do Cluster {cluster}'}]
    ))

# Criar o gr√°fico
fig = go.Figure(data=data)

# Adicionar o menu dropdown ao layout
fig.update_layout(
    updatemenus=[dict(
        type='dropdown',
        buttons=buttons,
        direction='down',
        showactive=True,
        x=0,
        xanchor='left',
        y=1.15,
        yanchor='top'
    )],
    title=f'Candles do Cluster {clusters[0]}',
    xaxis_title='Data',
    yaxis_title='Pre√ßo',
    xaxis_rangeslider_visible=False,
    template='plotly_white'
)

fig.show()

"""#Cadeia de Markov

#Mapear
"""

print(df.head(3))

import ast


data = {
    'Current_Sequence': ['(87, 92, 2)', '(12, 45, 6)', '[3, 5, 7]'],
    'Predicted_Next_State': [1, 0, 2],
    'Probability': [0.8, 0.6, 0.9],
}

df_pred = pd.DataFrame(data)

def safe_literal_eval(val):
    if isinstance(val, str):
        try:
            return ast.literal_eval(val)
        except (ValueError, SyntaxError):
            # Se n√£o for poss√≠vel avaliar, retorna None ou o valor original
            return None  # ou return val
    elif isinstance(val, (list, tuple)):
        # Se j√° for uma lista ou tupla, retorna como est√°
        return val
    else:
        # Se for de outro tipo, trata conforme necess√°rio
        return None  # ou return val

# Aplicar a fun√ß√£o segura para converter 'Current_Sequence'
df_pred['Current_Sequence'] = df_pred['Current_Sequence'].apply(safe_literal_eval)
print(df_pred)

# Defina a data inicial
start_date = '2002-05-23'  # Ajuste para a data inicial dos seus dados

# Crie uma sequ√™ncia de datas com o mesmo n√∫mero de registros do DataFrame
df['Date'] = pd.date_range(start=start_date, periods=len(df), freq='D')

# Verifique se a coluna 'Date' foi criada
print(df['Date'].head())

# Criar a coluna 'Reversal_Signal' com zeros
df['Reversal_Signal'] = 0

# Verifique se a coluna 'Reversal_Signal' foi criada
print(df['Reversal_Signal'].head())

df['Date'] = pd.to_datetime(df['Date'])

# Definir 'Date' como √≠ndice, mantendo a coluna no DataFrame
df.set_index('Date', inplace=True, drop=False)

if 'Cluster' not in df.columns:

    raise ValueError("A coluna 'Cluster' n√£o existe no DataFrame. Por favor, crie-a antes de prosseguir.")

df_reversal = df[df['Reversal_Signal'] == 1]

"""##Transi√ß√£o"""

#  Extrair a sequ√™ncia de estados

sequence = df['Cluster'].values

#  Construir os contadores de transi√ß√£o para a cadeia de Markov de ordem 3

transition_counts = {}
for i in range(len(sequence) - 3):
    current_state = (sequence[i], sequence[i+1], sequence[i+2])  # Sequ√™ncia atual de 3 estados
    next_state = sequence[i+3]  # Pr√≥ximo estado

    if current_state not in transition_counts:
        transition_counts[current_state] = {}
    if next_state not in transition_counts[current_state]:
        transition_counts[current_state][next_state] = 0
    transition_counts[current_state][next_state] += 1

#  Calcular as probabilidades de transi√ß√£o

transition_probabilities = {}
for current_state, next_states in transition_counts.items():
    total_transitions = sum(next_states.values())
    transition_probabilities[current_state] = {}
    for next_state, count in next_states.items():
        transition_probabilities[current_state][next_state] = count / total_transitions

"""##Predi√ß√£o"""

#  Prever o pr√≥ximo estado

def predict_next_state(current_sequence, transition_probabilities):
    if current_sequence in transition_probabilities:
        next_states = transition_probabilities[current_sequence]
        predicted_next_state = max(next_states, key=next_states.get)
        probability = next_states[predicted_next_state]
        return predicted_next_state, probability
    else:
        return None, 0

# Aplicar a predi√ß√£o a cada sequ√™ncia

predicted_next_states = []
probabilities = []
current_sequences = []
dates = []

for i in range(len(sequence) - 3):
    current_sequence = (sequence[i], sequence[i+1], sequence[i+2])
    predicted_state, probability = predict_next_state(current_sequence, transition_probabilities)
    current_sequences.append(current_sequence)
    predicted_next_states.append(predicted_state)
    probabilities.append(probability)
    dates.append(df['Date'].iloc[i+3])  # Data correspondente ao pr√≥ximo estado

# Criar o DataFrame com as predi√ß√µes

df_pred = pd.DataFrame({
    'Date': dates,
    'Current_Sequence': current_sequences,
    'Predicted_Next_State': predicted_next_states,
    'Probability': probabilities
})

"""#Revers√£o"""

#  Definir o mapeamento de clusters para tend√™ncias
cluster_trend_map = {
    # N√∫mero do Cluster: 'Tend√™ncia'
    0: 'Alta',     # Uptrend
    1: 'Baixa',    # Downtrend
    2: 'Lateral',  # Sideways trend

}

def safe_literal_eval(val):
    if isinstance(val, str):
        try:
            return ast.literal_eval(val)
        except (ValueError, SyntaxError):
            # Se n√£o for poss√≠vel avaliar, retorna None ou o valor original
            return None  # ou return val
    elif isinstance(val, (list, tuple)):
        # Se j√° for uma lista ou tupla, retorna como est√°
        return val
    else:
        # Se for de outro tipo, trata conforme necess√°rio
        return None  # ou return val

# Aplicar a fun√ß√£o segura para converter 'Current_Sequence'
df_pred['Current_Sequence'] = df_pred['Current_Sequence'].apply(safe_literal_eval)

# Converter 'Predicted_Next_State' para inteiro se necess√°rio
df_pred['Predicted_Next_State'] = df_pred['Predicted_Next_State'].astype(int)

# Mapear as tend√™ncias para as sequ√™ncias atuais
df_pred['Current_Trend'] = df_pred['Current_Sequence'].apply(
    lambda seq: tuple(cluster_trend_map.get(s, 'Neutro') for s in seq)
)

# Mapear a tend√™ncia prevista
df_pred['Predicted_Next_Trend'] = df_pred['Predicted_Next_State'].map(cluster_trend_map).fillna('Neutro')

def detect_reversal(row):
    current_trend_last = row['Current_Trend'][-1]
    predicted_trend = row['Predicted_Next_Trend']
    probability = row['Probability']

    # Definir um limiar de probabilidade
    threshold = 0.7  # Ajuste conforme necess√°rio
    if (predicted_trend != current_trend_last) and (probability >= threshold):
        return 1
    else:
        return 0

# Aplicar a fun√ß√£o para criar a coluna 'Reversal_Signal'
df_pred['Reversal_Signal'] = df_pred.apply(detect_reversal, axis=1)

# Preparar o DataFrame para o merge
df_pred_merge = df_pred[['Date', 'Reversal_Signal']].copy()
df_pred_merge.set_index('Date', inplace=True)

# Renomear a coluna 'Reversal_Signal' para evitar conflitos
df_pred_merge.rename(columns={'Reversal_Signal': 'Reversal_Signal_Pred'}, inplace=True)

# Realizar o merge com 'df'
df = df.merge(df_pred_merge, left_index=True, right_index=True, how='left')

# Preencher valores NaN em 'Reversal_Signal_Pred' com 0
df['Reversal_Signal_Pred'] = df['Reversal_Signal_Pred'].fillna(0).astype(int)

# Verificar as primeiras linhas do DataFrame resultante
print(df[['Date', 'Cluster', 'Reversal_Signal_Pred']].head())

"""#Pr√≥ximo Estado"""

def predict_next_state(current_sequence, transition_probabilities):
    # L√≥gica para prever o pr√≥ximo estado com base nas probabilidades de transi√ß√£o
    # Retorna o estado previsto e a probabilidade associada
    # Isso depende de como voc√™ calculou transition_probabilities

    # Exemplo gen√©rico:
    next_states = transition_probabilities.get(current_sequence)
    if next_states:
        # Supondo que next_states seja um dicion√°rio {estado: probabilidade}
        predicted_state = max(next_states, key=next_states.get)
        probability = next_states[predicted_state]
        return predicted_state, probability
    else:
        return None, 0

  # 12. Obter a sequ√™ncia atual (√∫ltimos 3 estados)
sequence = df['Cluster'].tolist()  # Certifique-se de que 'Cluster' est√° presente em 'df'
current_sequence = tuple(sequence[-3:])  # Pega os √∫ltimos 3 estados

# 13. Prever o pr√≥ximo estado usando a fun√ß√£o 'predict_next_state'
predicted_state, probability = predict_next_state(current_sequence, transition_probabilities)

# 14. Verificar e interpretar o resultado
if predicted_state is not None:
    predicted_trend = cluster_trend_map.get(predicted_state, 'Desconhecido')
    print(f"O pr√≥ximo estado previsto √©: {predicted_state}")
    print(f"A tend√™ncia associada ao estado previsto √©: {predicted_trend}")
    print(f"A probabilidade da previs√£o √©: {probability:.2%}")
else:
    print("A sequ√™ncia atual n√£o est√° presente nas probabilidades de transi√ß√£o.")

# 9. Prever V√°rios Estados no Futuro

n_steps = 3  # N√∫mero de passos futuros a prever (ajuste conforme necess√°rio)
current_sequence = (sequence[-3], sequence[-2], sequence[-1])
predicted_states = []
probabilities = []

for step in range(1, n_steps + 1):
    predicted_state, probability = predict_next_state(current_sequence, transition_probabilities)
    if predicted_state is None:
        print(f"N√£o √© poss√≠vel prever o estado para o passo {step} com base na sequ√™ncia atual.")
        break
    predicted_states.append(predicted_state)
    probabilities.append(probability)
    predicted_trend = cluster_trend_map.get(predicted_state, 'Desconhecido')
    print(f"Passo {step}: Estado previsto: {predicted_state} (Tend√™ncia: {predicted_trend}) com probabilidade de {probability:.2%}")
    # Atualizar a sequ√™ncia atual para incluir o estado previsto
    current_sequence = (current_sequence[1], current_sequence[2], predicted_state)

"""#Cadeia de Markov de Ordem 2


"""

df['Date'] = pd.to_datetime(df['Date'])

# Construir as probabilidades de transi√ß√£o para ordem 2
sequence_order2 = sequence  # Mesma sequ√™ncia de estados

transition_counts_order2 = {}
for i in range(len(sequence_order2) - 2):
    current_sequence_order2 = (sequence_order2[i], sequence_order2[i+1])
    next_state = sequence_order2[i+2]
    if current_sequence_order2 not in transition_counts_order2:
        transition_counts_order2[current_sequence_order2] = {}
    if next_state not in transition_counts_order2[current_sequence_order2]:
        transition_counts_order2[current_sequence_order2][next_state] = 0
    transition_counts_order2[current_sequence_order2][next_state] += 1

# Calcular as probabilidades de transi√ß√£o para ordem 2
transition_probabilities_order2 = {}
for current_sequence, next_states in transition_counts_order2.items():
    total_transitions = sum(next_states.values())
    transition_probabilities_order2[current_sequence] = {state: count / total_transitions for state, count in next_states.items()}

# Fun√ß√£o para prever o pr√≥ximo estado de ordem 2
def predict_next_state_order2(current_sequence, transition_probabilities):
    if current_sequence in transition_probabilities:
        next_states = transition_probabilities[current_sequence]
        predicted_state = max(next_states, key=next_states.get)
        probability = next_states[predicted_state]
        return predicted_state, probability
    else:
        return None, 0

# Utilizar a fun√ß√£o de ordem 2 se a de ordem 3 falhar
if predicted_state is None:
    current_sequence_order2 = (sequence[-2], sequence[-1])
    predicted_state, probability = predict_next_state_order2(current_sequence_order2, transition_probabilities_order2)
    if predicted_state is not None:
        predicted_trend = cluster_trend_map.get(predicted_state, 'Desconhecido')
        print(f"(Ordem 2) O pr√≥ximo estado previsto √©: {predicted_state}")
        print(f"(Ordem 2) A tend√™ncia associada √©: {predicted_trend}")
        print(f"(Ordem 2) A probabilidade da previs√£o √©: {probability:.2%}")
    else:
        print("N√£o foi poss√≠vel prever o pr√≥ximo estado com base na cadeia de Markov de ordem 2.")

df['Date'] = pd.to_datetime(df['Date'])

# 5. Incorporar a previs√£o ao DataFrame

# Criar um DataFrame com a previs√£o
df_prediction = pd.DataFrame({
    'Date': [df['Date'].iloc[-1] + pd.Timedelta(days=1)],  # Data do pr√≥ximo per√≠odo (ajuste conforme necess√°rio)
    'Predicted_State': [predicted_state],
    'Predicted_Trend': [predicted_trend],
    'Probability': [probability]
})

# Verificar a cria√ß√£o de 'df_prediction'
print(df_prediction)

# Se 'next_date' n√£o estiver definido, podemos assumir que seja o pr√≥ximo dia ap√≥s o √∫ltimo dispon√≠vel em 'df'
last_date = df['Date'].iloc[-1]
next_date = last_date + pd.Timedelta(days=1)

# Criar um novo DataFrame para a previs√£o
df_prediction = pd.DataFrame({
    'Date': [next_date],
    # Voc√™ pode estimar os pre√ßos 'Open', 'High', 'Low', 'Close' com base em alguma l√≥gica ou deixar em branco
    # Neste exemplo, vou usar o √∫ltimo pre√ßo de fechamento como uma estimativa simples
    'Open': [df['Close'].iloc[-1]],
    'High': [df['Close'].iloc[-1]],
    'Low': [df['Close'].iloc[-1]],
    'Close': [df['Close'].iloc[-1]]
})

# Concatenar os dados hist√≥ricos com a previs√£o (para incluir a previs√£o no gr√°fico de candles)
df_combined = pd.concat([df, df_prediction], ignore_index=True)

# Criar o gr√°fico de candles
fig = go.Figure(data=[go.Candlestick(
    x=df_combined['Date'],
    open=df_combined['Open'],
    high=df_combined['High'],
    low=df_combined['Low'],
    close=df_combined['Close'],
    name='Pre√ßo'
)])

# Adicionar a marca√ß√£o da previs√£o no gr√°fico
fig.add_trace(go.Scatter(
    x=[next_date],
    y=[df_prediction['Close'].iloc[0]],
    mode='markers',
    marker=dict(color='blue', size=12, symbol='star'),
    name='Previs√£o',
    hovertext=[f"Estado Previsto: {predicted_state}<br>Tend√™ncia: {predicted_trend}<br>Probabilidade: {probability:.2%}"],
    hoverinfo='text'
))

# Atualizar o layout do gr√°fico
fig.update_layout(
    title='Gr√°fico de Candles com Previs√£o',
    xaxis_title='Data',
    yaxis_title='Pre√ßo',
    xaxis_rangeslider_visible=False,
    legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1)
)

# Exibir o gr√°fico
fig.show()

"""#Gr√°fico Candles Com Sinais de Revers√£o"""

df['Date'] = df.index

# Obter o n√∫mero de clusters
num_clusters = df['Cluster'].nunique()
clusters = sorted(df['Cluster'].unique())

# Gerar uma lista de cores usando um colormap
cluster_colors = px.colors.sample_colorscale('Rainbow', [n/(num_clusters - 1) for n in range(num_clusters)])

# Criar um dicion√°rio que mapeia cada cluster a uma cor
cluster_color_map = {cluster: color for cluster, color in zip(clusters, cluster_colors)}

# Criar a figura
fig = go.Figure()

# Adicionar os candles, coloridos por cluster
for cluster in clusters:
    df_cluster = df[df['Cluster'] == cluster]
    fig.add_trace(go.Candlestick(
        x=df_cluster['Date'],
        open=df_cluster['Open'],
        high=df_cluster['High'],
        low=df_cluster['Low'],
        close=df_cluster['Close'],
        name=f'Cluster {cluster}',
        increasing_line_color=cluster_color_map[cluster],
        decreasing_line_color=cluster_color_map[cluster],
        showlegend=False,
        hovertext=[f'Date: {d}<br>Open: {o}<br>High: {h}<br>Low: {l}<br>Close: {c}<br>Cluster: {cluster}'
                   for d, o, h, l, c in zip(df_cluster['Date'], df_cluster['Open'], df_cluster['High'], df_cluster['Low'], df_cluster['Close'])],
        hoverinfo='text'
    ))

# Filtrar os pontos com sinal de revers√£o
df_reversal = df[df['Reversal_Signal_Pred'] == 1]

# Adicionar os marcadores de revers√£o
fig.add_trace(go.Scatter(
    x=df_reversal['Date'],
    y=df_reversal['High'],  # Posicionar o marcador no topo do candle
    mode='markers',
    marker=dict(color='yellow', size=10, symbol='triangle-up'),
    name='Sinal de Revers√£o',
    hovertext=['Sinal de Revers√£o<br>Date: {}'.format(d) for d in df_reversal['Date']],
    hoverinfo='text'
))

fig.update_layout(
    title='Gr√°fico Candlestick com Clusters e Sinais de Revers√£o',
    xaxis_title='Data',
    yaxis_title='Pre√ßo',
    xaxis_rangeslider_visible=False,  # Remover o rangeslider para melhorar a performance
    hovermode='x unified',
    template='plotly_white',
    autosize=False,
    width=1200,
    height=600
)

# Ajustar a exibi√ß√£o dos eixos
fig.update_xaxes(rangeslider_visible=False)
fig.update_yaxes(automargin=True)

#  Limitar o DataFrame aos √∫ltimos 200 registros (opcional)
df = df.tail(50).reset_index(drop=True)
fig.show()