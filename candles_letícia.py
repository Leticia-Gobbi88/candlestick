# -*- coding: utf-8 -*-
"""Candles_let√≠cia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hgKZUfQ815_PdjgvWcuFLgNv6jAxNFuf

# Desafio Candles![b12e17_1a71b33107174d25a437d93f0d97120d~mv2.png](data:image/png;base64,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)

**Let√≠cia Oliveira Gobbi**

##Bibliotecas
"""

pip install plotly pandas

pip install mplfinance

pip install bokeh

!pip install hmmlearn

# Importa√ß√£o das bibliotecas b√°sicas
import pandas as pd
import numpy as np
from urllib.request import urlopen

# Para visualiza√ß√£o
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from PIL import Image
import seaborn as sns
import plotly.graph_objs as go
from plotly.offline import plot
from plotly.subplots import make_subplots
import plotly.express as px
import plotly.io as pio
import matplotlib.dates as mdates
from mplfinance.original_flavor import candlestick_ohlc



# Para escalonamento
from sklearn.preprocessing import MinMaxScaler

# Para clustering
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from sklearn.cluster import KMeans
from sklearn.mixture import GaussianMixture
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import silhouette_score

# Para processamento de dados temporais
import datetime
from io import BytesIO

# Para a Cadeia de Markov
from collections import defaultdict
from matplotlib.dates import date2num
from sklearn.preprocessing import LabelEncoder
from collections import Counter
import time
from hmmlearn import hmm


# Ignorar avisos
import warnings
warnings.filterwarnings('ignore')

def load_img(url, with_background=False):
  # Open the URL and get the data as bytes
  response = urlopen(url)
  image_data = response.read()

  # Create a BytesIO object from the data
  image_file = BytesIO(image_data)

  # Open the image from the BytesIO object using Pillow
  img = Image.open(image_file)

  # Convert the image to RGBA mode (if not already)
  img = img.convert('RGBA')

  # Create a new background image with white pixels
  background = Image.new('RGBA', img.size, (255, 255, 255, 255))  # White with full alpha

  # Paste the image onto the background, preserving transparency
  background.paste(img, (0, 0), img)

  # Convert the image to a NumPy array
  img_array = np.array(background)

  # Plot the image
  plt.figure()
  plt.imshow(img_array)
  plt.axis('off')
  plt.show()

"""##Explora√ß√£o dos Dados"""

# Carregar o dataset
df = pd.read_excel('/content/Challenge3_NFLX.xlsx')

# Exibir as primeiras linhas
print(df.head())

# Load the dataset
file_path = 'https://docs.google.com/spreadsheets/d/1mp8oSZjKtJcURz3O5v0Dp5a3LODKR8bGrgpmrQxVksg/export?format=csv'
data = pd.read_csv(file_path)

# Ensure 'Date' column is in datetime format
data['Date'] = pd.to_datetime(data['Date'])

# Sort the dataset by 'Date' in ascending order
data = data.sort_values(by='Date', ascending=True)

# Reset the index after sorting
data = data.reset_index(drop=True)

# Display the first five rows of the dataset
data.head()

# Verificar se h√° valores nulos
print(df.isnull().sum())

# Visualizar as tr√™s primeiras linhas
print(df.head(3))

df.isnull().sum()

"""##Tratamento dos Dados"""

# Load dataset
#file_path = 'dataset.csv'
#data = pd.read_csv(file_path)

# Calculate Body Size
data['Body_Size'] = abs(data['Close'] - data['Open'])
data['Body_Size'] = pd.to_numeric(data['Body_Size'], errors='coerce')

# Calculate Upper Wick
data['Upper_WickShadow'] = data['High'] - data[['Open', 'Close']].max(axis=1)
data['Upper_WickShadow'] = data['Upper_WickShadow'].astype(float)

# Calculate Lower Wick
data['Lower_WickShadow'] = data[['Open', 'Close']].min(axis=1) - data['Low']
data['Lower_WickShadow'] = data['Lower_WickShadow'].astype(float)

# Calculate Total Size of Candle
totalcandle = data['Body_Size'] + data['Upper_WickShadow'] + data['Lower_WickShadow']

# Convert Body Size to percentage
data['Body_Size_Percent'] = data['Body_Size'] / totalcandle
data['Body_Size_Percent'] = data['Body_Size_Percent'].astype(float)

# Convert Upper Wick to percentage
data['Upper_WickShadow_Percent'] = data['Upper_WickShadow'] / totalcandle
data['Upper_WickShadow_Percent'] = data['Upper_WickShadow_Percent'].astype(float)

# Convert Lower Wick to percentage
data['Lower_WickShadow_Percent'] = data['Lower_WickShadow'] / totalcandle
data['Lower_WickShadow_Percent'] = data['Lower_WickShadow_Percent'].astype(float)

# Bullish = 1 and Bearish = 0
data['Candle_Direction'] = data.apply(lambda row: 1 if row['Close'] > row['Open'] else 0, axis=1)

# Create new columns for conditions when Body Size <= 25%
data['Body_Size_Percent_1'] = (data['Body_Size_Percent'] > 0) & (data['Body_Size_Percent'] <= 0.01)
data['Body_Size_Percent_5'] = (data['Body_Size_Percent'] > 0.01) & (data['Body_Size_Percent'] <= 0.05)
data['Body_Size_Percent_10'] = (data['Body_Size_Percent'] > 0.05) & (data['Body_Size_Percent'] <= 0.10)
data['Body_Size_Percent_15'] = (data['Body_Size_Percent'] > 0.10) & (data['Body_Size_Percent'] <= 0.15)
data['Body_Size_Percent_20'] = (data['Body_Size_Percent'] > 0.15) & (data['Body_Size_Percent'] <= 0.20)
data['Body_Size_Percent_25'] = (data['Body_Size_Percent'] > 0.20) & (data['Body_Size_Percent'] <= 0.25)

# Convert boolean to integer
# Put 0 or 1
columns_to_convert = [
    'Body_Size_Percent_1', 'Body_Size_Percent_5', 'Body_Size_Percent_10',
    'Body_Size_Percent_15', 'Body_Size_Percent_20', 'Body_Size_Percent_25'
]
data[columns_to_convert] = data[columns_to_convert].astype(int)

# Check for null values
nulls = data.isnull().any().any()
if nulls:
  data = data.dropna()

# Save in CSV file
data.to_csv('dataset.csv', index=False)

data[['Date', 'Open', 'Close', 'Body_Size_Percent', 'Upper_WickShadow_Percent',
      'Lower_WickShadow_Percent', 'Candle_Direction', 'Body_Size_Percent_1',
      'Body_Size_Percent_5', 'Body_Size_Percent_10', 'Body_Size_Percent_15',
      'Body_Size_Percent_20', 'Body_Size_Percent_25']].head()

# Verificar a quantidade de NaNs em cada coluna
print("Quantidade de valores ausentes em cada coluna:")
print(df.isna().sum())

# Verificar se h√° valores ausentes em todo o conjunto de dados
total_missing = df.isna().sum().sum()
print(f"\nTotal de valores ausentes no conjunto de dados: {total_missing}")

"""##Visualiza√ß√£o de Dados"""

# Se quiser visualizar a distribui√ß√£o de 'Close' sem agrupamento:
plt.figure(figsize=(8, 6))
sns.boxplot(y=df['Close'])
plt.title('Box Plot do Pre√ßo de Fechamento')
plt.ylabel('Pre√ßo de Fechamento')
plt.show()

# Criar o histograma do pre√ßo de fechamento
plt.figure(figsize=(10, 6))
sns.histplot(df['Close'], bins=50, kde=True)
plt.title('Distribui√ß√£o de Frequ√™ncia do Pre√ßo de Fechamento')
plt.xlabel('Pre√ßo de Fechamento')
plt.ylabel('Frequ√™ncia')
plt.show()

"""##Escalonamento de Valores"""

# Supondo que 'df' √© o seu DataFrame
print("Features dispon√≠veis no DataFrame:")
print(df.columns.tolist())

data = pd.DataFrame(data)

missing_cols = [col for col in columns_to_scale if col not in data.columns]
print("Colunas ausentes:", missing_cols)

file_path = 'dataset.csv'

# Tenta carregar o CSV com diferentes separadores (v√≠rgula, ponto e v√≠rgula, tab)
data = pd.read_csv(file_path, sep=",", engine="python")

print(data.head())  # Verifica se os dados est√£o corretos
print(data.columns)  # Exibe os nomes das colunas
print(data.shape)  # Confirma se tem o n√∫mero correto de colunas e linhas

print(data.columns)
print(data.dtypes)

columns_to_scale = ['Body_Size_Percent', 'Upper_WickShadow_Percent', 'Lower_WickShadow_Percent']

if all(col in data.columns for col in columns_to_scale):
    scaler = MinMaxScaler()
    data[columns_to_scale] = scaler.fit_transform(data[columns_to_scale])
    print("Escalonamento aplicado com sucesso!")
else:
    print("Algumas colunas para escalonamento n√£o foram encontradas.")

"""##Clusterizando"""

#Global variable
scaled_features = None

def test_cluster_k(range_k):
    global scaled_features  # Use the global variable

    # Select features for clustering
    features = data[["Body_Size_Percent", "Upper_WickShadow_Percent", "Lower_WickShadow_Percent", "Candle_Direction",
    "Body_Size_Percent_1", "Body_Size_Percent_5", "Body_Size_Percent_10", "Body_Size_Percent_15", "Body_Size_Percent_20",
                     "Body_Size_Percent_25"]]

    # Data Normalization
    scaler = StandardScaler()
    scaled_features = scaler.fit_transform(features)

    # Define range for the number of clusters
    k_values = range(2, range_k)

    # Initialize lists for metrics
    inertia = []  # KMeans inertia
    silhouette_scores_kmeans = []  # Silhouette scores for KMeans
    silhouette_scores_gmm = []  # Silhouette scores for GMM
    bic_scores = []  # BIC for GMM
    aic_scores = []  # AIC for GMM

    # Test different numbers of clusters
    for k in k_values:
        # Step 1: KMeans Initialization
        kmeans = KMeans(n_clusters=k, init='k-means++', random_state=42)
        kmeans.fit(scaled_features)
        inertia.append(kmeans.inertia_)
        kmeans_labels = kmeans.labels_

        # Check if silhouette score can be computed
        if len(set(kmeans_labels)) > 1:
            silhouette_scores_kmeans.append(silhouette_score(scaled_features, kmeans_labels))
        else:
            silhouette_scores_kmeans.append(None)

        # Step 2: GMM Refinement using KMeans centroids
        gmm = GaussianMixture(n_components=k, covariance_type='full', random_state=42,
                              means_init=kmeans.cluster_centers_)
        gmm.fit(scaled_features)
        gmm_labels = gmm.predict(scaled_features)

        # Check if silhouette score can be computed
        if len(set(gmm_labels)) > 1:
            silhouette_scores_gmm.append(silhouette_score(scaled_features, gmm_labels))
        else:
            silhouette_scores_gmm.append(None)

        bic_scores.append(gmm.bic(scaled_features))
        aic_scores.append(gmm.aic(scaled_features))

    # Plotting Evaluation Metrics
    plt.figure(figsize=(12, 12))

    # Plot 1: KMeans Inertia (Elbow Method)
    plt.subplot(4, 1, 1)
    plt.plot(k_values, inertia, marker='o')
    plt.title('Elbow Method (KMeans)')
    plt.xlabel('Number of Clusters (k)')
    plt.ylabel('Inertia (SSE)')

    # Plot 2: Silhouette Scores for KMeans and GMM
    plt.subplot(4, 1, 2)
    plt.plot(k_values, silhouette_scores_kmeans, marker='o', label='KMeans')
    plt.plot(k_values, silhouette_scores_gmm, marker='o', label='GMM', color='orange')
    plt.title('Silhouette Scores')
    plt.xlabel('Number of Clusters (k)')
    plt.ylabel('Silhouette Score')
    plt.legend()

    # Plot 3: BIC Scores for GMM
    plt.subplot(4, 1, 3)
    plt.plot(k_values, bic_scores, marker='o', label='BIC', color='blue')
    plt.title('BIC Scores (GMM)')
    plt.xlabel('Number of Clusters (k)')
    plt.ylabel('BIC')

    # Plot 4: AIC Scores for GMM
    plt.subplot(4, 1, 4)
    plt.plot(k_values, aic_scores, marker='o', label='AIC', color='green')
    plt.title('AIC Scores (GMM)')
    plt.xlabel('Number of Clusters (k)')
    plt.ylabel('AIC')

    plt.tight_layout()
    plt.show()

# Test range for k = 150
test_cluster_k(150)

"""##K-Means"""

# Assuming the optimal number of clusters is k
optimal_k = 110

# global variable
global dataset_clustered
dataset_clustered = None

# Select features for clustering
features = data[["Body_Size_Percent", "Upper_WickShadow_Percent", "Lower_WickShadow_Percent", "Candle_Direction",
    "Body_Size_Percent_1", "Body_Size_Percent_5", "Body_Size_Percent_10", "Body_Size_Percent_15", "Body_Size_Percent_20",
                     "Body_Size_Percent_25"]]

# Data Normalization
scaler = StandardScaler()
scaled_features = scaler.fit_transform(features)

# Select the optimal number of clusters (the one with the highest silhouette score)
#optimal_k = k_values[np.argmax(silhouette_scores_kmeans)]

# Applying K-Means clustering with the optimal k clusters
# init='k-means++': This parameter controls how the initial cluster centers (centroids) are chosen.
# random_state=42: This ensures reproducibility.
kmeans = KMeans(n_clusters=optimal_k, init='k-means++', random_state=42)
data['Cluster_Code'] = kmeans.fit_predict(scaled_features)

# Save in CSV file
data.to_csv('dataset_clustered.csv', index=False)
dataset_clustered = data

# Display the data with the cluster assignment
dataset_clustered[['Date', 'Open', 'Close', 'Body_Size', 'Upper_WickShadow', 'Lower_WickShadow', 'Candle_Direction', 'Cluster_Code']].head()

"""

```
# Isto est√° formatado como c√≥digo
```

##An√°lise
"""

# Load the data
#dataset_clustered = pd.read_csv('dataset_clustered.csv')

# Initialize an empty list to store the results
results = []

# Loop
for i in range(optimal_k):  # generates numbers from 0 to optimal_k
    # Filter the dataset for the current cluster
    cluster = dataset_clustered[dataset_clustered['Cluster_Code'] == i]

    # Calculate the required metrics
    total_objects = len(cluster)
    range_body_size_min = cluster['Body_Size_Percent'].min()
    range_body_size_max = cluster['Body_Size_Percent'].max()
    range_upper_shadow_min = cluster['Upper_WickShadow_Percent'].min()
    range_upper_shadow_max = cluster['Upper_WickShadow_Percent'].max()
    range_lower_shadow_min = cluster['Lower_WickShadow_Percent'].min()
    range_lower_shadow_max = cluster['Lower_WickShadow_Percent'].max()
    range_candle_direction_min = cluster['Candle_Direction'].min()
    range_candle_direction_max = cluster['Candle_Direction'].max()

    # Exibir informa√ß√µes
    print(f"Total of objects in Cluster {i}: {total_objects}")
    print(f"Range Body_Size_Percent: Min = {range_body_size_min} Max = {range_body_size_max}")
    print(f"Range Upper_WickShadow_Percent: Min = {range_upper_shadow_min} Max = {range_upper_shadow_max}")
    print(f"Range Lower_WickShadow_Percent: Min = {range_lower_shadow_min} Max = {range_lower_shadow_max}")
    print(f"Range Candle_Direction: Min = {range_candle_direction_min} Max = {range_candle_direction_max}")
    print()

    # Append the results to the list as a dictionary
    results.append({
        'Cluster_Code': i,
        'Total_Objects': total_objects,
        'Body_Size_Min': range_body_size_min,
        'Body_Size_Max': range_body_size_max,
        'Upper_Shadow_Min': range_upper_shadow_min,
        'Upper_Shadow_Max': range_upper_shadow_max,
        'Lower_Shadow_Min': range_lower_shadow_min,
        'Lower_Shadow_Max': range_lower_shadow_max,
        'Candle_Direction_Min': range_candle_direction_min,
        'Candle_Direction_Max': range_candle_direction_max
    })

# Convert the list of results into a DataFrame
cluster_analysis = pd.DataFrame(results)

# Save the DataFrame to a CSV file
cluster_analysis.to_csv('cluster_analysis_results.csv', index=False)

print("Results saved to 'cluster_analysis_results.csv'")

"""#Plotando"""

# Plot the bar chart
plt.figure(figsize=(20, 5))
bars = plt.bar(cluster_analysis['Cluster_Code'], cluster_analysis['Total_Objects'], color='skyblue')

# Add labels and title
plt.title('Total Objects by Cluster Code', fontsize=15)
plt.xlabel('Cluster Code', fontsize=10)
plt.ylabel('Total Objects', fontsize=10)

# Rotate x-axis labels to 90 degrees and ensure full visibility
plt.xticks(cluster_analysis['Cluster_Code'], rotation=90,  fontsize=8)

# Add value labels on top of each bar
for bar in bars:
    height = bar.get_height()
    plt.text(bar.get_x() + bar.get_width()/2, height + 0.5, str(int(height)),
             ha='center', va='bottom')

# Show the plot
plt.tight_layout()
plt.show()

# Set figure size
plt.figure(figsize=(15, 6))

# Calculate the range between Min and Max
body_size_range = cluster_analysis['Body_Size_Max'] - cluster_analysis['Body_Size_Min']

# Create vertical bars starting at Body_Size_Min with lengths of the range
plt.bar(cluster_analysis['Cluster_Code'], body_size_range, bottom=cluster_analysis['Body_Size_Min'],
        color='skyblue', edgecolor='black', alpha=0.7)

# Ensure all Cluster_Code values appear as x-axis labels
plt.xticks(ticks=cluster_analysis['Cluster_Code'], labels=cluster_analysis['Cluster_Code'], rotation=90, fontsize=8)

# Labels and title
plt.title('Body Size Range by Cluster Code', fontsize=15)
plt.xlabel('Cluster Code', fontsize=12)
plt.ylabel('Range %', fontsize=12)

# Show grid for better readability
plt.grid(axis='x', linestyle='--', alpha=0.4)

# Show plot
plt.tight_layout()
plt.show()

# Set figure size
plt.figure(figsize=(15, 6))

# Calculate the range between Min and Max
uper_shadow_range = cluster_analysis['Upper_Shadow_Max'] - cluster_analysis['Upper_Shadow_Min']

# Create vertical bars starting at Body_Size_Min with lengths of the range
plt.bar(cluster_analysis['Cluster_Code'], uper_shadow_range, bottom=cluster_analysis['Upper_Shadow_Min'],
        color='green', edgecolor='black', alpha=0.7)

# Ensure all Cluster_Code values appear as x-axis labels
plt.xticks(ticks=cluster_analysis['Cluster_Code'], labels=cluster_analysis['Cluster_Code'], rotation=90, fontsize=8)

# Labels and title
plt.title('Uper Shadow by Cluster Code', fontsize=15)
plt.xlabel('Cluster Code', fontsize=12)
plt.ylabel('Range %', fontsize=12)

# Show grid for better readability
plt.grid(axis='x', linestyle='--', alpha=0.4)

# Show plot
plt.tight_layout()
plt.show()

# Set figure size
plt.figure(figsize=(15, 6))

# Calculate the range between Min and Max
lower_shadow_range = cluster_analysis['Lower_Shadow_Max'] - cluster_analysis['Lower_Shadow_Min']

# Create vertical bars starting at Body_Size_Min with lengths of the range
plt.bar(cluster_analysis['Cluster_Code'], lower_shadow_range, bottom=cluster_analysis['Lower_Shadow_Min'],
        color='red', edgecolor='black', alpha=0.7)

# Ensure all Cluster_Code values appear as x-axis labels
plt.xticks(ticks=cluster_analysis['Cluster_Code'], labels=cluster_analysis['Cluster_Code'], rotation=90, fontsize=8)

# Labels and title
plt.title('Lower Shadow by Cluster Code', fontsize=15)
plt.xlabel('Cluster Code', fontsize=12)
plt.ylabel('Range %', fontsize=12)

# Show grid for better readability
plt.grid(axis='x', linestyle='--', alpha=0.4)

# Show plot
plt.tight_layout()
plt.show()

# Function to load candles by cluster (randomly select 15 rows)
def load_candle_by_cluster_random(cluster_code):
    # Load the dataset
    #file_path = 'dataset_clustered.csv'
    #data = pd.read_csv(file_path)
    data = dataset_clustered

    # Ensure 'Date' is in datetime format before applying mdates.date2num
    data['Date'] = pd.to_datetime(data['Date'])

    # Filter the dataset by 'Cluster_Code'
    filtered_data = data[data['Cluster_Code'] == cluster_code]

    # Ensure there is data for the specified cluster_code
    if filtered_data.empty:
        print(f"No data found for Cluster_Code = {cluster_code}.")
        return

    # Prepare the 'Date' column for candlestick_ohlc (requires numerical format)
    filtered_data['Date'] = filtered_data['Date'].apply(mdates.date2num)

    # Randomly select 15 rows (or fewer if less than 15 rows exist)
    random_samples = filtered_data.sample(n=min(15, len(filtered_data)))

    # Set up the grid for subplots
    n_cols = 15
    n_rows = (len(random_samples) + n_cols - 1) // n_cols  # Ceiling division for rows

    fig, axes = plt.subplots(n_rows, n_cols, figsize=(15, 5 * n_rows))
    axes = axes.flatten()  # Flatten to iterate easily

    # Plot each candlestick for the sampled entries
    for i, (_, row) in enumerate(random_samples.iterrows()):
        ax = axes[i]

        # Prepare data for candlestick_ohlc
        ohlc_data = [[row['Date'], row['Open'], row['High'], row['Low'], row['Close']]]

        # Create a candlestick chart in the subplot
        candlestick_ohlc(ax, ohlc_data, width=0.3, colorup='g', colordown='r')

        # Set the title for the subplot
        ax.set_title(f'Cluster: {cluster_code}')

        # Remove the x-axis for the subplot
        ax.set_xticks([])
        #ax.set_xlabel('')
        ax.set_xlabel(mdates.num2date(row['Date']).strftime('%Y-%m-%d'))

    # Remove extra subplots if any
    for j in range(len(random_samples), len(axes)):
        axes[j].axis('off')  # Turn off unused axes

    # Adjust the layout to avoid overlap
    plt.tight_layout()
    plt.show()

# Loop through the range Cluster 0 to optimal_k
for cluster_id in range(optimal_k):
    load_candle_by_cluster_random(cluster_id)

"""#Gr√°fico de Candles"""

def load_candlestick():

  # Load dataset
  #file_path = 'dataset_clustered.csv'
  #data = pd.read_csv(file_path)
  data = dataset_clustered

  # Convert the date column to datetime
  data['Date'] = pd.to_datetime(data['Date'], format='%Y-%m-%d')

  # Get user input for the date range (30-day range)
  start_date = input("Enter the start date (YYYY-MM-DD): ")
  end_date = input("Enter the end date (YYYY-MM-DD): ")

  # Filter data for the given date range
  mask = (data['Date'] >= start_date) & (data['Date'] <= end_date)
  filtered_data = data.loc[mask]

  # Convert 'Date' to numerical format required by matplotlib for candlestick_ohlc
  filtered_data['Date'] = mdates.date2num(filtered_data['Date'])

  # Create a new figure
  fig, ax = plt.subplots(figsize=(10, 5))

  # Plot the candlestick chart
  candlestick_ohlc(ax, filtered_data[['Date', 'Open', 'High', 'Low', 'Close']].values, width=0.6, colorup='g', colordown='r')

  # Formatting the x-axis to show dates
  ax.xaxis_date()
  ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
  plt.xticks(rotation=45)

  # Plot the Classification_Code below each candle
  for idx, row in filtered_data.iterrows():
      ax.text(row['Date'], row['High'] + (row['High'] - row['Low']) * 0.05,
            str(int(row['Cluster_Code'])),
            horizontalalignment='center', fontsize=8, color='blue')

  # Set labels and title
  plt.xlabel('Date')
  plt.ylabel('Price')
  plt.title('Candlestick Chart with Cluster Codes')

  # Show the plot
  plt.tight_layout()
  plt.show()

# 2016-05-01 to 2022-05-31
load_candlestick()

"""#Cadeia de Markov

#Mapear
"""

# Load data
data = pd.read_csv('dataset_clustered.csv')
#data = dataset_clustered
data['Date'] = pd.to_datetime(data['Date'], format='%Y-%m-%d')

# Calculate moving averages
data['MA_5'] = data['Close'].rolling(window=5).mean()  # 5-period moving average
data['MA_10'] = data['Close'].rolling(window=10).mean()  # 10-period moving average

# Identify Bullish/Bearish trends with 3-candle patterns
def classify_candles(df):
    trends = []
    for i in range(2, len(df)):
        # Extract the last three candles
        c1, c2, c3 = df.iloc[i-2], df.iloc[i-1], df.iloc[i]

        # Bullish pattern: Higher lows and higher closes
        if (c2['Low'] > c1['Low']) and (c3['Low'] > c2['Low']) and \
           (c2['Close'] > c1['Close']) and (c3['Close'] > c2['Close']):
            trends.append('Bullish')
        # Bearish pattern: Lower highs and lower closes
        elif (c2['High'] < c1['High']) and (c3['High'] < c2['High']) and \
             (c2['Close'] < c1['Close']) and (c3['Close'] < c2['Close']):
            trends.append('Bearish')
        else:
            trends.append('Neutral')

    # Pad with NaN for the first two rows
    return [np.nan, np.nan] + trends

data['Trend'] = classify_candles(data)

# Combine with moving averages for confirmation
def confirm_trend(row):
    if row['Trend'] == 'Bullish' and row['MA_5'] > row['MA_10']:
        return 'Bullish Confirmed'
    elif row['Trend'] == 'Bearish' and row['MA_5'] < row['MA_10']:
        return 'Bearish Confirmed'
    else:
        return 'No Confirmation'

data['Trend_Confirmed'] = data.apply(confirm_trend, axis=1)

# Filter and visualize results
bullish_trends = data[data['Trend_Confirmed'] == 'Bullish Confirmed']
bearish_trends = data[data['Trend_Confirmed'] == 'Bearish Confirmed']

# Convert the list of results into a DataFrame
dataset_trends = pd.DataFrame(data)

# Save in CSV file
dataset_trends.to_csv('dataset_trends.csv', index=False)

# Display the first few rows
dataset_trends.head()

"""Visualizar"""

data = dataset_trends

# Get user input for the date range
start_date = input("Enter the start date (YYYY-MM-DD): ")
end_date = input("Enter the end date (YYYY-MM-DD): ")

# Convert 'Date' column to datetime if not already done
data['Date'] = pd.to_datetime(data['Date'])
bullish_trends['Date'] = pd.to_datetime(bullish_trends['Date'])
bearish_trends['Date'] = pd.to_datetime(bearish_trends['Date'])

# Filter data for the selected date range
filtered_data = data[(data['Date'] >= start_date) & (data['Date'] <= end_date)]
filtered_bullish_trends = bullish_trends[(bullish_trends['Date'] >= start_date) & (bullish_trends['Date'] <= end_date)]
filtered_bearish_trends = bearish_trends[(bearish_trends['Date'] >= start_date) & (bearish_trends['Date'] <= end_date)]

# Prepare the data for candlestick_ohlc
ohlc_data = filtered_data[['Date', 'Open', 'High', 'Low', 'Close']].copy()
ohlc_data['Date'] = date2num(ohlc_data['Date'])  # Convert dates to numerical format for plotting
ohlc_data = ohlc_data[['Date', 'Open', 'High', 'Low', 'Close']]  # Reorder columns for candlestick_ohlc

# Plot the candlestick chart
fig, ax = plt.subplots(figsize=(14, 8))

# Plot candlestick data
candlestick_ohlc(ax, ohlc_data.values, width=0.6, colorup='green', colordown='red', alpha=0.8)

# Plot moving averages
ax.plot(filtered_data['Date'], filtered_data['Close'], color='purple', linestyle='--', linewidth=1.5, label='Close Price')
ax.plot(filtered_data['Date'], filtered_data['MA_5'], color='orange', linestyle='--', linewidth=1.5, label='5-day MA')
ax.plot(filtered_data['Date'], filtered_data['MA_10'], color='blue', linestyle='--', linewidth=1.5, label='10-day MA')

# Offset value for markers to stay far from each candle
marker_offset = (filtered_data['High'] - filtered_data['Low']).mean() * 0.6  # 60% of the average candle height

# Plot bullish and bearish trend markers
ax.scatter(
    filtered_bullish_trends['Date'],
    filtered_bullish_trends['Close'] + marker_offset,
    color='green',
    marker='^',
    s=100,
    label='Bullish Confirmed',
)
ax.scatter(
    filtered_bearish_trends['Date'],
    filtered_bearish_trends['Close'] - marker_offset,
    color='red',
    marker='v',
    s=100,
    label='Bearish Confirmed',
)

# Set title, labels, and legend
ax.set_title(f'Candlestick Chart with Trends ({start_date} to {end_date})', fontsize=16)
ax.set_xlabel('Date', fontsize=12)
ax.set_ylabel('Price', fontsize=12)
ax.legend(loc='best', fontsize=10)
ax.grid(True, linestyle='--', alpha=0.6)

# Plot the Classification_Code below each candle
for idx, row in filtered_data.iterrows():
    ax.text(row['Date'], row['High'] + (row['High'] - row['Low']) * 0.1,
          str(int(row['Cluster_Code'])),
          horizontalalignment='center', fontsize=11, color='blue', backgroundcolor='white')

# Format x-axis for dates
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
fig.autofmt_xdate()

# Adjust layout and display the chart
plt.tight_layout()
plt.show()

"""##Pre-Processing"""

# Load dataset
#data = pd.read_csv('dataset_trends.csv')
data = dataset_trends

df = pd.DataFrame(data)

# Create a new DataFrame to store the selected rows
dataset_trends_filtered = pd.DataFrame(columns=df.columns)

# Iterate through the DataFrame
i = 0
while i < len(df) - 1:
    current_trend = df['Trend_Confirmed'][i]
    next_trend = df['Trend_Confirmed'][i + 1]

    if (current_trend == 'Bullish Confirmed' and next_trend in ('Bullish Confirmed', 'Bearish Confirmed', 'No Confirmation')) or \
       (current_trend == 'Bearish Confirmed' and next_trend in ('Bearish Confirmed', 'Bullish Confirmed', 'No Confirmation')) or \
       (current_trend == 'No Confirmation' and next_trend in ('Bullish Confirmed', 'Bearish Confirmed')):

        # Add the current row and next row to the new DataFrame
        dataset_trends_filtered = pd.concat([dataset_trends_filtered, df.iloc[[i, i + 1]]], ignore_index=True)

        # Check if the NEXT row by itself meets any the condition (if the pair didn't match)
        next_index = i + 2  # Index of the next row

        if next_index < len(df): # Make sure we're not going past the end of the DataFrame
            next_trend_row1 = df['Trend_Confirmed'][next_index]
            next_trend_row2 = df['Trend_Confirmed'][next_index + 1]

            if not ((next_trend_row1 == 'Bullish Confirmed' and next_trend_row2 in ('Bullish Confirmed', 'Bearish Confirmed', 'No Confirmation')) or \
              (next_trend_row1 == 'Bearish Confirmed' and next_trend_row2 in ('Bearish Confirmed', 'Bullish Confirmed', 'No Confirmation')) or \
              (next_trend_row1 == 'No Confirmation' and next_trend_row2 in ('Bullish Confirmed', 'Bearish Confirmed'))):

              #
              if not (next_trend == 'No Confirmation'):
                # Increment only next_index
                dataset_trends_filtered = pd.concat([dataset_trends_filtered, df.iloc[[next_index]]], ignore_index=True)

              # move to the next row
              i += 2
            else:
              # move to the next pair of rows
              i += 2
    else:
        i += 1  # Increment i by 1 to move to the next row

# Save in CSV file
dataset_trends_filtered.to_csv('dataset_trends_filtered.csv', index=False)

# Display the first few rows
dataset_trends_filtered.head()

# Load your data

# Label Encoding: Convert strings to numerical values
le_cluster = LabelEncoder()
le_trend_confirmed = LabelEncoder()

dataset_trends_filtered['Cluster_Code_Encoded'] = le_cluster.fit_transform(dataset_trends_filtered['Cluster_Code'])
dataset_trends_filtered['Trend_Confirmed_Encoded'] = le_trend_confirmed.fit_transform(dataset_trends_filtered['Trend_Confirmed'])

# Save in CSV file
dataset_trends_filtered.to_csv('dataset_trends_filtered_preprocessed.csv', index=False)

# Display the processed dataset
dataset_trends_filtered.head()

# Define Sequence Length
sequence_length = 2

# Create Sequences of Observations (using encoded values)
observations = []
for i in range(len(dataset_trends_filtered) - sequence_length + 1):
    sequence = dataset_trends_filtered.iloc[i:i + sequence_length][['Cluster_Code_Encoded', 'Trend_Confirmed_Encoded']].values # Using ENCODED values
    observations.append(sequence)

# Convert to numpy array
observations = np.array(observations)

# Prepare data for hmmlearn

# Reshape for hmmlearn. Expects a 2D array of shape (n_samples, n_features).
# We need to reshape our 3D data into 2D by concatenating the features.
n_samples = observations.shape[0]
n_features = observations.shape[2]  # Features per timestep (2 in this case)

# Reshape to (n_samples * sequence_length, n_features)
reshaped_observations = observations.reshape(-1, n_features)  # Flatten sequences

"""#Training"""

# Define Number of States (using the original Cluster_Code for number of states)
n_states = len(dataset_trends_filtered['Cluster_Code'].unique())  # Important: Use original, not encoded, values for number of states.

# HMM Training (using the reshaped observations)
# HMM Type: CategoricalHMM is used here because the observations are categorical.
# If features were continuous, we use a different HMM type (GaussianHMM).
model = hmm.CategoricalHMM(n_components=n_states, n_iter=100, random_state=42) # Add random_state for reproducibility

# Fit the model
# Baum-Welch algorithm is used
# It takes the training data (reshaped_observations) and estimates the transition and emission probabilities that define the HMM.

# Must provide the lengths argument to model.fit() when working with sequences of varying or fixed lengths.
# Since all your sequences are the same length, we provide a list of sequence_length repeated n_samples times.
# This tells the HMM where each sequence begins and ends.

# Record the start time
start_time = time.time()

# Crucially, provide the flattened data.
model.fit(reshaped_observations, lengths=[sequence_length] * n_samples) # Provide sequence lengths!

# Record the end time
end_time = time.time()

# Calculate the elapsed time
elapsed_time = end_time - start_time

# Convert elapsed time to HH:MM:SS format
formatted_time = time.strftime("%H:%M:%S", time.gmtime(elapsed_time))

print(f"Elapsed time: {formatted_time}")

"""#Matrix Transition"""

# Get Transition and Emission Probabilities
transition_matrix = model.transmat_
emission_matrix = model.emissionprob_
startprob = model.startprob_

# Retrieve the model parameters
print("Transition Matrix (A):\n", transition_matrix, "\n")
print("Emission Matrix (B):\n", emission_matrix, "\n")
print("Initial Probabilities (œÄ):\n", startprob)

"""##Create Mapping"""

# Create Mappings (for decoding later)
# Create dictionaries (cluster_mapping, trend_confirmed_mapping)
# This is important so you can interpret the results.
cluster_mapping = {i: code for i, code in enumerate(le_cluster.classes_)}  # Use classes_
print(cluster_mapping)
trend_confirmed_mapping = {i: trend for i, trend in enumerate(le_trend_confirmed.classes_)} # Use classes_
print(trend_confirmed_mapping)

"""#Test Markov"""

cluster_code_X = 23 # change for test
cluster_code_Y = 8  # change for test
cluster_code_Z = 73 # change for test

# 0 => Bearish Confirmed
# 1 => Bullish Confirmed
# 2 => No Confirmation
trend_option = 1    # change for test

if trend_option == 0:
  trend_confirmed = "Bearish Confirmed"
elif trend_option == 1:
  trend_confirmed = "Bullish Confirmed"
elif trend_option == 2:
  trend_confirmed =  "No Confirmation"

# Encode the values
cluster_code_encoded_X = le_cluster.transform([cluster_code_X])[0]
cluster_code_encoded_Y = le_cluster.transform([cluster_code_Y])[0]
cluster_code_encoded_Z = le_cluster.transform([cluster_code_Z])[0]
trend_confirmed_encoded = le_trend_confirmed.transform([trend_confirmed])[0]

"""[texto do link](https://)#Create Mapping

Probabilidade de Cluster_A dado a tend√™ncia A
"""

# Use Emission Matrix

# Find the probabilities of all cluster codes given the Trend_Confirmed state
probabilities_given_trend1 = emission_matrix[trend_confirmed_encoded]

prob1 = probabilities_given_trend1[cluster_code_encoded_X]
print(f"Probability of Cluster_Code = {cluster_code_X} given \
Trend_Confirmed = '{trend_confirmed}'\
\nP(Cluster_Code = {cluster_code_X} | Trend_Confirmed = '{trend_confirmed}'): {prob1}")

"""Probabilidade do Cluster_Z dado a tend√™ncia A"""

# Use Emission Matrix

# Find the probabilities of all cluster codes given the Trend_Confirmed state
probabilities_given_trend2 = emission_matrix[trend_confirmed_encoded]

prob2 = probabilities_given_trend2[cluster_code_encoded_Y]
print(f"Probability of Cluster_Code = {cluster_code_Y} given \
Trend_Confirmed = '{trend_confirmed}' \
\nP(Cluster_Code = {cluster_code_Y} | Trend_Confirmed = '{trend_confirmed}'): {prob2}")

"""Probabilidade de Cluster_Code X dado que Cluster_Code Y ocorreu"""

# Use Transition Matrix
prob4 = transition_matrix[cluster_code_encoded_Y, cluster_code_encoded_X]

print(f"Probability of Cluster_Code = {cluster_code_X} occurring given \
Cluster_Code = {cluster_code_Y} occurred \
\nP(Cluster_Code = {cluster_code_X} | Previous Cluste_Code = {cluster_code_Y}): {prob4}")

""" Probabilidade de Cluster_Code X dado que Cluster_Code Y e Cluster_Code Z ocorreram, ambos com mesma tend√™ncia"""

# Given a sequence of observations and a condition on the Trend_Confirmed state,
# and we want to know the probability of a specific next state.

# Create the sequence (including the target state)
sequence_initial5 = np.array([[cluster_code_encoded_Y, trend_confirmed_encoded],
                            [cluster_code_encoded_Z, trend_confirmed_encoded],
                            [cluster_code_encoded_X, trend_confirmed_encoded]])

# Reshape for hmmlearn
reshaped_sequence5 = sequence_initial5.reshape(1, sequence_initial5.shape[0] * sequence_initial5.shape[1])

# Calculate the probability of this *complete* sequence
# Forward-Backward algorithm
log_prob = model.score(reshaped_sequence5) # Use score for log probability.

# Convert back to probability
prob5 = np.exp(log_prob)

print(f"Probability of Cluster_Code = {cluster_code_X} occurring given \
that Cluster_Code = {cluster_code_Y} and Cluster_Code= {cluster_code_Z} \
\nP(Cluster_Code = {cluster_code_X} | Previous Cluste_Code = {cluster_code_Y} \
& {cluster_code_Z}, all Trend_Confirmed = '{trend_confirmed}'): {prob5}")

"""Probabilidade ap√≥s Cluster_Code X, Y, Z manter o mesma tend√™ncia"""

# Create the sequence (including the target state)
sequence_initial6 = np.array([
    [cluster_code_encoded_X, trend_confirmed_encoded],
    [cluster_code_encoded_Y, trend_confirmed_encoded],
    [cluster_code_encoded_Z, trend_confirmed_encoded]
])

# Filter the dataset and get unique 'Cluster_Code' values according to Trend_Confirmed
possible_next_states = dataset_trends_filtered[
    dataset_trends_filtered['Trend_Confirmed_Encoded'] == trend_confirmed_encoded]['Cluster_Code_Encoded'].unique()

probabilities = []

for next_state in possible_next_states:

    # Ensure next_state is added with the correct shape
    next_step = np.array([[next_state, trend_confirmed_encoded]])  # Shape (1,2)

    # Concatenate properly
    sequence = np.vstack([sequence_initial6, next_step])  # Shape should now be (4,2)

    # Reshape sequence correctly
    reshaped_sequence = sequence.reshape(1, -1)  # Keep a single row for HMM input

    # Forward-Backward algorithm
    log_prob = model.score(reshaped_sequence)
    probabilities.append(np.exp(log_prob))

# Sum the probabilities of all "staying" sequences
prob6 = sum(probabilities)

print(f"Probability of transitioning to Bullish/Bearish Confirmed after \
\nCluster_Code = {cluster_code_X}, Cluster_Code = {cluster_code_Y}, \
Cluster_Code = {cluster_code_Z} \
\nP(Next state is Bullish/Bearish confirmed or No Confirmation \
\nafter sequence {cluster_code_X} ‚Üí {cluster_code_Y} ‚Üí {cluster_code_Z}, \
all Trend_Confirmed = '{trend_confirmed}'): {prob6}")

"""Probabilidade da tend√™ncia ser Bullish ou Bearish, dado um sequ√™ncia a cada 2 ou 3 candles"""

def find_top_combinations(df, n=10, combo_length=2):
    if combo_length not in (2, 3):
        raise ValueError("combo_length must be 2 or 3")

    combinations = []
    for i in range(len(df) - combo_length + 1):
        combo = tuple(df['Cluster_Code'][i:i + combo_length].values)
        combinations.append(combo)

    counts = Counter(combinations)
    return counts.most_common(n)

def find_next_cluster_and_trend_encoded(df, combo):
    indices = []
    for i in range(len(df) - len(combo)):
        current_combo = tuple(df['Cluster_Code_Encoded'][i:i + len(combo)].values)
        if current_combo == combo:
            indices.append(i)

    next_data = []
    for i in indices:
        if i + len(combo) < len(df):
            next_cluster = df['Cluster_Code_Encoded'][i + len(combo)]
            next_trend = df['Trend_Confirmed_Encoded'][i + len(combo)]
            next_data.append((next_cluster, next_trend))

    return next_data

def predict_next_cluster_and_trend(df, combo):
    """Predicts the next most likely Cluster_Code and its trend using HMM."""
    try:
      # Encode Cluster Codes
      encoded_combo = tuple(le_cluster.transform(list(combo)))

      # Find the next clusters and trends for the sequence
      next_data = find_next_cluster_and_trend_encoded(df, encoded_combo)

      if next_data:
          prob_bullish = 0.0
          prob_bearish = 0.0
          cluster_probabilities = Counter()

          for next_cluster, next_trend in next_data:
              observed_sequence = np.array([[next_cluster]])

              # Get predicted hidden states
              hidden_states = model.predict(observed_sequence)

              for state in hidden_states:
                  emission_prob = model.emissionprob_[state, next_cluster]
                  cluster_probabilities[next_cluster] += model.startprob_[state] * emission_prob

                  # Determine trend probabilities
                  # print(f"Next Cluster_Code: {next_cluster} and Trend_Confirmed: {next_trend}")
                  if next_trend == 1:  # Bullish Confirmed
                      prob_bullish += model.startprob_[state] * emission_prob
                  elif next_trend == 0:  # Bearish Confirmed
                      prob_bearish += model.startprob_[state] * emission_prob

          # Identify the most likely next Cluster_Code
          most_likely_cluster = max(cluster_probabilities, key=cluster_probabilities.get)
          most_likely_cluster_prob = cluster_probabilities[most_likely_cluster]

          # Decode Cluster_Code back to its original value
          most_likely_cluster_decoded = le_cluster.inverse_transform([most_likely_cluster])[0]

          print(f"Most likely next Cluster_Code: {most_likely_cluster_decoded} (Probability: {most_likely_cluster_prob:.4f})")
          print(f"Probability of next Trend_Confirmed being 'Bullish Confirmed': {prob_bullish:.4f}")
          print(f"Probability of next Trend_Confirmed being 'Bearish Confirmed': {prob_bearish:.4f}")
      else:
        print(f"Sequence not found")
    except Exception as e:
      print(f"Error: {e}")

# Load dataset
df = pd.DataFrame(dataset_trends_filtered)

# Get user input for combo length
while True:
    try:
        combo_length = int(input("Enter combination length (2 or 3): "))
        if combo_length in (2, 3):
            break
        else:
            print("Invalid input. Please enter 2 or 3.")
    except ValueError:
        print("Invalid input. Please enter a number.")

top_combinations = find_top_combinations(df, combo_length=combo_length)

for combo, count in top_combinations:
    print(f"Combination: {combo}, Count: {count}")
    predict_next_cluster_and_trend(df, combo)
    print("-" * 30)

# Get user input for a custom sequence of Cluster_Codes
while True:
    user_input = input("\nEnter a sequence of Cluster_Codes (comma-separated, e.g., 26,37): ")
    try:
        user_sequence = list(map(int, user_input.split(",")))
        if len(user_sequence) not in (2, 3):
            print("Please enter exactly 2 or 3 Cluster_Codes.")
            continue
        break
    except ValueError:
        print("Invalid input. Please enter numbers separated by commas.")

# Run the prediction for user input sequence
predict_next_cluster_and_trend(df, user_sequence)